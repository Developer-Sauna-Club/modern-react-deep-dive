### 2.2.1 DOM과 브라우저 렌더링 과정

DOM은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. `브라우저의 렌더링 엔진`은 HTML을 파싱해 `DOM 트리`를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다. (스타일시트가 포함된 link 태그를 발견하면 해당 href 파일을 다운한다.)
4. 브라우저의 렌더링 엔진은 CSS도 파싱해 CSS 노드로 구성된 트리 `CSSOM`를 만든다.
5. 브라우저는 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 DOM 트리에 적용한다. (`레이아웃`(좌표 계산) + `페인팅`(색과 같은 유효한 모습을 그리는 과정))

- 레이아웃은 필연적으로 페이팅일으킨다. 하지만 페인팅은 독립적으로 일어난다.

### 2.2.2 가상 DOM의 탄생 배경

브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다.
또한 렌더링이 완료된 이후에도 사용자의 인터렉션으로 웹페이지가 변경되는 상황 또한 고려해야 한다.

- 특정한 요소의 색상이 변경되는 경우 => 리페인팅
- 요소의 위치와 크기가 변경되는 경우 => 레이아웃 + 리페인팅
- 또한 DOM 변경이 일어나는 요소가 많은 자식 요소를 가지고 있는 경우 => 하위 자식 요소도 함꼐 변경되어야 하기 떄문에 더 많은 비용을 브라우저와 사용자가 지불하게 된다.

SPA 측면에서 보면 하나의 페이지에서 모든 작업이 일어난다. 그러다 보니 재랜더링 과정이 많이 일어 날 수 밖에 없다. 비용이 커진다.

사용자의 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자에게 수고스럽기 때문에 개발자는 결과적으로 만들어지는 DOM 결과물 하나를 알고 싶을 것이다.

`그래서 등장한 것이 브라우저의 DOM이 아닌 리액트가 관리하는 가상 DOM이다.`

- 가상 DOM

  - 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트(package.json의 react-dom)가 실제 변경에 대한 준비가 완료 됐을때 실제 브라우저의 DOM에 반영한다.
    - 이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 되면 실제로는 여러 번 발생했을 렌더링 과정을 최소화 할 수 있다.

- 가상 DOM이 DOM보다 빠르다?
  - 무조건 빠르다는 것은 틀린말이고 이 가상 DOM 방식이 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠르다는 말은 맞다.

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트는 어떻게 여러 번의 렌더링 과정을 압축해 최소한의 렌더링 단위를 만들어 내는 걸까?
이러한 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 `리액트 파이버 (React Fiber)`이다.

#### 리액트 파이버란?

`리액트 파이버`는 자바스크립트 객체다. 파이버는 파이버 재조정자(fiber reconciler)가 관리한다.

- 파이버 재조정자(fiber reconciler)의 역할

  - 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집 => 둘 사이에 차이 O => 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청

  <br/>

> 재조정 (reconciliation)
> fiber reconciler가 리액트에서 어떤 부분을 새롭게 레더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

- 리액트 파이버의 목표

  - 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다. (반응성 문제..? 라는 단어가 조금 어렵네)
    📌 이를 위해 파이버는 다음과 같은 일을 할 수 있다. (비동기적으로 일어난다.)
    - 작업을 작은 단위로 분할하고 쪼갠 다음, 우선 순위를 매긴다.
    - 이러한 작업을 일시 정지하고 나중에 시작할 수 있다.
    - 이전에 했던 작업을 재사용하거나 필요하지 않은 경우에는 폐기 할 수 있다.

- 리액트 파이버는 어떻게 구현돼 있을까?
  - 파이버는 하나의 작업 단위로 구성돼 있다.
  - 리액트는 이러한 작업 단위를 하나씩 처리하고 `finishedWork()`라는 작업으로 마무리 한다. (렌더 단계)
  - 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다. (커밋 단계) (동기식으로 일어나고 중단 될 수 없다.)

> 파이버는 리액트 요소와 유사하다고 느낄 수 있지만 한 가지 중요한 차이점은 리액트 요소는 렌더링이 발생 할 때마다 새롭게 생성되지만 파이버는 가급적이면 재사용된다. 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용된다.

- 파이버는 단순한 JS 객체로 구성돼 있다.
- 하나의 element에 하나의 파이버가 생성되는 1 : 1 관계이다.

  - 1:1로 매칭된 정보를 가지고 있는 것이 tag이다.
  - 파이버의 태그에는 값이 할당된다.
    `var HostComponent = 5` => 웹의 `div` 와 같은 요소이다.

- 생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다.
- 리액트가 fiber를 처리할 때마다 직접 바로 처리하기도 하고 스케쥴링하기도 한다.
  - 즉, 이러한 작업들은 작은 단위로 나눠서 처리할 수 도 있고, 애니메이션과 같이 우선순위가 높은 작언은 가능한 한 빠르게 처리하거나, 납은 작업을 연기시키는 등 좀 더 유연하게 처리된다.
- 리액트의 가상 돔은 값을 가지고 있는 UI를 관리하는 라이브러리 라고도 생각할 수 있다.
  - 파이버의 객체 값에서 알 수 있듯이 리액트의 핵심 원칙으 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다.

#### 리액트의 파이버 트리 2개 = 현재 모습을 담은 파이버 트리 + 작업 중인 상태를 나타내는 workInProgress 트리

- 더블 버퍼링
  - 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInprogress 트리를 현재 트리로 바꾼다. 이렇게 함으로써, 불완전한 트리를 보여주지 않을 수 있다.
  - 좀 더 풀어 설명하면, 보이지 않는 곳에서 그다음으로 그려야 할 그림을 미리 그린 다음, 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법이다.
- current 트리(현재 UI 렌더링을 위해 존재하는 트리)를 기준으로 작업이 시작되고, 만약 업데이트가 발생하면 파이버는 새로 받은 데이터로 새로운 workInProgress 트리를 빌드한다. workInProgress 트리를 빌드하는 작업이 끝나면 다음 렌더링에 이 트리를 사용한다.

### 2.2.4 파이버와 가상 DOM

- 파이버와 가상 DOM은 동일한 개념이 아니다.
  - 파이버는 RN와 같은 브라우저가 아닌 환경에서도 사용된다.
  - 가상 돔은 웹 애플리케시션에서만 통용되는 개념이다.
  - 하지만 파이버를 통해서 조정되는 과정은 일맥상통하다.
- 파이버는 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이고, 이 파이버는 리액트 아키텍쳐 내부에서 비동기적으로 이뤄진다. 메모리상에서 먼저 수행해서(렌더 과정 + 커밋 과정) 최종적인 결과물만 실제 브라우저 DOM에 적용하는 방식이 가상 돔 방식이다.

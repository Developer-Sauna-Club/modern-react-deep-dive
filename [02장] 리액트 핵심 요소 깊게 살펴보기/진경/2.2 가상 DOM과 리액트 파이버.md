### 2.2.1 DOM과 브라우저 렌더링 과정

DOM은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. `브라우저의 렌더링 엔진`은 HTML을 파싱해 `DOM 트리`를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다. (스타일시트가 포함된 link 태그를 발견하면 해당 href 파일을 다운한다.)
4. 브라우저의 렌더링 엔진은 CSS도 파싱해 CSS 노드로 구성된 트리 `CSSOM`를 만든다.
5. 브라우저는 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 DOM 트리에 적용한다. (`레이아웃`(좌표 계산) + `페인팅`(색과 같은 유효한 모습을 그리는 과정))

- 레이아웃은 필연적으로 페이팅일으킨다. 하지만 페인팅은 독립적으로 일어난다.

### 2.2.2 가상 DOM의 탄생 배경

브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다.
또한 렌더링이 완료된 이후에도 사용자의 인터렉션으로 웹페이지가 변경되는 상황 또한 고려해야 한다.

- 특정한 요소의 색상이 변경되는 경우 => 리페인팅
- 요소의 위치와 크기가 변경되는 경우 => 레이아웃 + 리페인팅
- 또한 DOM 변경이 일어나는 요소가 많은 자식 요소를 가지고 있는 경우 => 하위 자식 요소도 함꼐 변경되어야 하기 떄문에 더 많은 비용을 브라우저와 사용자가 지불하게 된다.

SPA 측면에서 보면 하나의 페이지에서 모든 작업이 일어난다. 그러다 보니 재랜더링 과정이 많이 일어 날 수 밖에 없다. 비용이 커진다.

사용자의 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자에게 수고스럽기 때문에 개발자는 결과적으로 만들어지는 DOM 결과물 하나를 알고 싶을 것이다.

`그래서 등장한 것이 브라우저의 DOM이 아닌 리액트가 관리하는 가상 DOM이다.`

- 가상 DOM

  - 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트(package.json의 react-dom)가 실제 변경에 대한 준비가 완료됐을때 실제 브라우저의 DOM에 반영한다.
    - 이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 되면 실제로는 여러 번 발생했을 렌더링 과정을 최소화 할 수 있다.

- 가상 DOM이 DOM보다 빠르다?
  - 무조건 빠르다는 것은 틀린말이고 이 가상 DOM 방식이 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠르다는 말은 맞다.

가상 DOM은 웹페이지가 표시해야 할

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트는 어떻게 여러 번의 렌더링 과정을 압축해 최소한의 렌더링 단위를 만들어 내는 걸까?
이러한 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 리액트 파이버(React Fiber)이다.

이게 양이 많네

### 2.2.4 파이버와 가상 DOM

매우 짧음!

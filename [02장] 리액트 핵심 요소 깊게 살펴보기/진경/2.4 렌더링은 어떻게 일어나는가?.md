> 리액트의 렌더링은 시간과 리소스를 소비해 수행되는 과정으로, 이 비용은 모두 웹 애플리케이션을 방문하는 사용자에게 청구된다. 시간이 길어지고 복잡해질수록 유저의 사용자 경험을 저해하기 때문이다. 고로 렌더링 과정을 최소한으로 줄여야 한다.

### 2.4.1 리액트의 렌더링이란?

- 브라우저에서의 렌더링 vs 리액트에서의 렌더링
  - 브라우저에서의 렌더링
    - HTML과 CSS 리소스를 기반으로 웹페이지를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미한다.
  - 리액트에서의 렌더링
    - 리액트 애플리케이션 트리 안의 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.
    - 만약 컴포넌트가 props와 state와 같은 상태값을 가지고 있지 않다면 오직 해당 컴포넌트가 반환하는 JSX 값에 기반해 렌더링이 일어나게 된다.
    - ⭐️ 지금까지 렌더링이라고 하면 화면에 UI를 그리는 작업이라고만 생각했는데 이는 브라우저의 렌더링에만 국한된 내용이었다. 리액트에서의 렌더링은 props와 state가 변경되면, 전과 후의 파이버 트리를 기반으로 가상 DOM을 비교해서 변경 부분만 DOM에 반영하기 위해 계산하는 과정이다.

### 2.4.2 리액트의 렌더링이 일어나는 이유

- 렌더링은 언제 일어날까?

  1. 최초 렌더링
     사용자가 처음 애플리케이션에 진입하면 당연히 렌더링해야 할 결과물이 필요하다. 리액트는 브라우저에 이 정보를 제공하기 위해 최조 렌더링을 수행한다.
  2. 리렌더링
     처음 애플리케이션에 진입했을 때 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다. 리렌더링이 발생하는 경우는 여러가지 이다.
  3. 클래스 컴포넌트 setState가 실행되는 경우
  4. 클래스 컴포넌트의 forceUpdate가 실행되는 경우
  5. 함수 컴포넌트의 `useState()`의 두 번째 배열 요소인 `setter`가 실행되는 경우
     `const [count, setCount] = useState(0);`
  6. 함수 컴포넌트의 `useReducer()`의 두 번째 배열 요소인 dispatch가 실행되는 경우
     `const [state, dispatch] = useReducer(reducer, initialState);`

     - dispatch는 액션을 발생시키는 함수로 `dispatch({ type: 'INCREMENT' })`와 같이 사용한다.

  7. 컴포넌트의 key props가 변경되는 경우

     - 일반적으로 key는 배열에서 하위 컴포넌트를 선언 할 때 사용된다.
     - ⭐️ 가끔 콘솔에 warning이 뜨는게 귀찮아서 `<Child key={Math.random()} />`과 같이 랜덤한 숫자를 넣을 때가 있었는데, 이렇게 되면 리렌더링이 일어날때 마다 sibling 컴포넌트를 명확히 구분할 수 없으므로 memo를 선언했어도 리렌더링이 발생한다. 즉, key 값의 변화는 리렌더링을 야기한다.

  > 리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동인한 요소를 식별하는 값이다. key가 없다면 단순히 파이버 내부의 sibling index만을 기준으로 컴포넌트를 비교하게 되는데 key 값이 있다면, 이를 이용해서 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값으로서 이용된다.

      ❗️❗️current 트리와 workInProgress 두 트리 사이에서 어떠한 컴포넌트가 변경이 있었는지 구별해야 하는데, 이 두 트리 사이에서 같은 컴포넌트인지를 구별하는 값이 key이다. key를 사용한다면 같은 컴포넌트인지 구별하는 작업을 더 효율적으로 할 수 있기 때문에 결과적으로 리렌더링 과정에서의 하나의 수고를 덜어 준다. `memo`를 사용하면 `<Child />`는 <Child key={index}/> 와 같은 효과를 준다. 보통 props가 바뀌면 리렌더링이 된다고는 알고 있었는데 key 또한 key props로 나타내는 것으로 볼때 key의 변화 또한 리렌더링을 발생시킨다고 생각하면 될 것 같다.

      6. props가 변경되는 경우
      7. 부모 컴포넌트가 렌더링될 경우
        - 부모 컴포넌트가 리렌더링 되면 자식 컴포넌트도 무조건 리렌더링된다.

  > ⭐️⭐️⭐️ useState 등으로 관리되지 않는 단순한 변수는 아무리 변경된다고 해도 리렌더링을 발생시키지 않아 변경된 값을 렌더링된 DOM에서 확인할 수 없다.

  ```
  let index = 0

  export default function App() {
    function handleButtonClick() {
      index += 1
    }

    return (
      <>
        <button onClick={handleButtonClick}>+</button>
      </>
    )
  }
  ```

  위의 예시를 보면 아무리 버튼을 눌러도 index 값은 `useState` 등으로 관리되지 않는 값이기 때문에 값이 변경되었다고 한들 리렌더링이 발생하지 않는다.

  > ⭐️⭐️⭐️ MobX와 Redux는 상태 관리 라이브러리 이지만 이것 만으로는 리렌더링을 이끌어 낼 수 없다. 그래서 각각 `mobx-react` 와 `react-redux` 와 같은 리액트 패키지를 설치해야만 변경된 상태에 따른 리렌더링으로 이어질 수 있다. recoil의 경우에는 별도의 리액트 패키지가 없어도 상태 관리가 되는데 이는 useState 등을 통해 리렌더링을 발생시킨다.

### 2.4.3 리액트의 렌더링 프로세스

- 렌더링이 어떤 과정으로 수행될까? (= 렌더링 프로세스)

  - 컴포넌트의 루트에서 부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
  - 업데이트가 필요하다고 지정돼 있는 컴포넌트르 발견하면 함수 컴포넌트의 경우에는 `FunctionComponent()` 그 자체를 호출한 뒤에, 그 결과물을 저장한다.
  - 렌더링 결과물은 JSX 문법으로 구성돼 있고 => JS로 컴파일 => `React.createElement()`를 호출하는 구문으로 변환된다. => 일반적인 JS 객체를 반환한다. => 렌더링 결과물

  ```
  // JSX
  function Hello() {
    return (
      <TestComponent a={35} b="yceffort">
        안녕하세요
      </TestComponent>
    )
  }

  // JS로 컴파일
  function Hello() {
    return React.createElement(
      TestComponent,
      { a: 35, b : 'yceffort' },
      '안녕하세요',
    )
  }

  // 렌더링 결과물
  { type: TestComponent, props: {a: 35, b: 'yceffort', children: '안녕하세요'} }
  ```

  - 렌더링 프로세스가 실행되면 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집하고 가상 DOM과 비교해서 모든 변경 사항을 수집한다. (reconcilation 재조정) => 이후 모든 변경 사항을 동기적으로 DOM에 적용한다.

### 2.4.4 렌더와 커밋

리액트의 렌더링(동기식) = 렌더 단계 + 커밋 단계

> 리액트의 렌더링(렌더 단계 => 커밋 단계) => 브라우저의 렌더링

- 렌더 단계
  - 리액트에서 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.
  - 즉, 컴포넌트를 실행해(render() or return) 이 결과와 이전 가상 DOM을 비교하는 과정을 통해 변경이 필요한 컴포넌트를 체크하는 단계이다. (주로 type, props, key를 비교한다.)
- 커밋 단계
  - 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다.
  - 커밋 단계가 끝나야 비로소 `브라우저의 렌더링`이 발생한다.

> `리액트의 렌더링`이 일어난다고 해서 무조건 `DOM의 업데이트(브라우저의 렌더링)`가 일어나는 것은 아니다.

만약 리액트의 렌더링 단계 중 렌더 단계에서 변경 사항이 감지되지 않았다면 커밋 단계는 일어나지 않고(= 브라우저의 DOM 업데이트) 당연히 브라우저의 렌더링도 일어나지 않는다.

> 리액트 18에서는 비동기 렌더링(동시성 렌더링)이 도입됐다. 10단원에서 보자.

### 2.4.5 일반적인 렌더링 시나리오 살펴보기

```
// 리액트 컴포넌트 트리의 렌더링 과정을 살펴보기 위한 예제
import {useStae} from 'react'

export default function A() {
...
}

function B() {
...
}

```

### 3.1.1 useState

> 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

#### 사용법

```
import {useState} from 'react'

const [state, useState] = useState(initialState)
```

- 초깃값을 넘겨주지 않으면 초깃값은 `undefined`이다.
  <br/>

#### useState 구현 살펴보기

- 아래의 코드가 동작하지 않았던 이유는 무엇일까?

  - React에서 렌더링이 언제 일어나는 지를 다시 생각해볼 필요가 있다.

    - React에서 렌더링은 함수 컴포넌트 기준 최초 렌더링시, `useState`의 setter가 실행되는 경우, useReducer의 `dispatch`가 실행되는 경우, key props가 변경되는 경우, props가 변경되는 경우, 부모 컴포넌트가 렌더링되는 경우 발생합니다. (**이 모든 경우는 함수 컴포넌트에서 반환한 결과물인 return 값을 비교해 리렌더링이 실행된다는 공통점을 가지고 있습니다.**)

      ```
      function Component() {
      let state = 'hello'

      function handleButtonClick() {
        state = 'hi'
        console.log(state)
      }

      return (
        <>
          <h1>{state}</hi>
          <button onClick={handleButtonClick}>hi</button>
        </>
      )
      }
      ```

    - 하지만 위의 코드 경우 버튼을 클릭하게 되면 콘솔에 `hi`가 찍히기는 하지만 `h1` 태그의 `state`의 경우에는 hello가 찍힐 것이다. 왜냐면 리렌더링이 발생할 조건에 부합하지 않기 때문에 리렌던링이 일어나지 않았기 때문이다.

    ```
    function Component() {
      const [,triggerRender] = useState()

      let state = 'hello'

      function handleButtonClick() {
        state = 'hi'
        triggerRender()
      }

      return (
        <>
          <h1>{state}</hi>
          <button onClick={handleButtonClick}>hi</button>
        </>
      )
    }
    ```

    - 위와 같이 코드를 변경한다면 triggerRender()가 실행되어 분명 리렌더링이 발생할 것이다. 하지만 리렌더링이 일어난다고 해도, 새롭게 실행되는 함수에서 `state`는 매번 hello로 초기화되어 버려 변경값 `hi`가 적용이 안 될 것이다. 그렇다면 useState는 어떤 구조로 이루어져 있을까?

  <br />

  - 시도1

    ```
    function useState(initialValue) {
      let internalState = initialValue

      function setState(newValue) {
        internalState = newValue
      }

      return [internalState, setState]
    }

    ```

    ```
    const [value, setValue] = useState(0)

    setValue(1)

    console.log(value) // 0
    ```

    - 위와 같이 구현하면 이전 예제에서의 `triggerRender`와 동일하게 리렌더링되면 초기화 되는 상황이 일어난다.
    - 클로저를 이용했다.
    - 클로저
      - 이미 실행이 끝난 함수가(실행 컨텍스트가 사라진) 아직 살아있는 함수의 스크프 체인에 의해 변수 객체가 유지되어 접근이 가능한 상황이라고 한다면, 여기는 아직 살아있는 함수(콜 스택에 실행 컨텍스트가 아직 올라가있는 함수)를 클로저 라고 부른다.
    - 여기서 클로저는 어떤 함수(useState) 내부에 선언된 함수(setState)가 실행이 종료된 이후에도(useState가 호출도니 이후에도) 지역변수인 state를 계속 참조할 수 있다는 것을 의미한다.
    - 아래의 구현 예시를 193p의 구현 예시를 보면 MyReact라고 불리는 클로저 내부에 useState와 관련된 정보(global, index)를 저장해 두고, 이를 필요할 때마다 꺼내놓는 형식으로 구성돼 있다.

#### 게으른 초기화

- `useState`에서 기본값을 선언하기 위해 useState() 인수로 원시값을 넣는 경우가 대부분이지만 useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 게으른 초기화를 사용한다. 이 게은른 초기화 함수는 오로지 state가 처음 만들어 질때만 사용된다. 이후 리렌더링 시에는 이 함수의 실행은 무시된다.

```
const [count, setCount] = useState(() => {
  Number.parseInt(window.localStorage.getItem(cacheKey)),
})
```

- 게으른 초기화는 언제 사용한느 것이 좋을까?
  - 무거운 연산이 요구될때
  - `localStorage`나 `sessionStorage`에 대한 접근, map, filter, find 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때 와 같이 무서운 연산을 포함해 실행 비용이 많이 드는 경우

### 3.1.2 useEffect

### 3.1.3 useMemo

### 3.1.4 useCallback

### 3.1.5 useRef

### 3.1.6 useContext

### 3.1.7 useReducer

### 3.1.8 useInperativeHandle

### 3.1.9 useLayoutEffect

### 3.1.10 useDebugValue

### 3.1.11 훅의 규칙

### Next.js 13과 리액트 18

#### 11.1.1 라우팅

Next.js 13 부터는 app 디렉터리 내부의 폴더명이 라우팅이 되며, 이 폴더에 포함될 수 있는 파일명(예약어)은 몇 가지로 제한 돼 있다.

1. layout.js

- 루트에서는 단 하나의 layout을 만들어 둘 수 있다. 모든 페이지에 영향을 미치는 공통 레이아웃이다.
- 주의
  - app 디렉터리 내부에서의 예약어다. 무조건 layout.{js|jsx|ts|tsx} 로 사용해야 하며 레이아웃 이외의 다른 목적으로 사용할 수 없다.
  - API 요청과 같은 비동기 작업을 수행할 수 있다.

2. page.js

- page가 받는 props

  - params

    - 선택값이다. `동적 라우트 파라미터`를 사용할 경우 해당 파라미터에 값이 들어온다.

          동적 라우트 파라미터

          - 라우팅 : 라우팅 경로(route)를 찾아가는 행위를 말한다. 라우팅을 통해서 다른 경로(url 주소)에 따라 다른 화면을 보여 줄 수 있습니다.
          - 동적 라우팅 : 정적이지 않은, 동적일 수 있는 경로에 대하여 라우팅이다. 라우트 경로에 특정 값을 넣어 해당 페이지로 이동할 수 있게 합니다. 동적 라우팅은 라우트 경로에 특정 값을 넣어 해당하는 페이지로 이동할 수 있게 한다.

          - 동적인 경로를 처리할 수 있는 방법으로 `Path Parameter(URL parameter)` 와 `Query Parameter`가 있다.

          1. Path Parameter(URL parameter)

          - `localhost:3000/product/2`
            `localhost:3000/product/45`
            의 경우 라우트 경로 끝에 들어가는 각기 다른 id 값들을 저장하느 매개 변수를 **Path Parameter** 라고 한다.
          - `:`는 path parameter가 올 것임을 의미합니다.
          - `path='/product/:id` 에서 id는 path parameter의 이름을 의미합니다.
          - 리액트에서 `useParams` 를 이용해서 `const {id} = useParams()` 와 같이 path parameter 에 접근할 수 있다.

          2. Query parameter

          - `?`로 시작하여 여러 개의 파라미터는 `&`로 구분됩니다.
          - `https://www.example.com/products?page=2&size=10

    `

  - searchParams

    - 웹 API의 일부로, URL의 **쿼리 파라미터**를 쉽게 다루기 위한 인터페이스를 제공한다.
    - URL에서 `?a=1`과 같은 URLSearchParams를 의미한다. 예를 들어 `?a=1&b=2`로 접근할 경우 searchParams 에는 `{ a: '1', b: '2' }`라는 js 객체 값이 오게 된다.
    - 주로 `URL` 객체와 함께 사용되며, URL의 **쿼리 파라미터**를 설정(append: 추가), 읽기(get), 수정(set) 및 삭제(delete) 할 수 있다.

      ```
      // URL 객체 생성
      const url = new URL('https://www.example.com/search?query=apple&sort=price');

      // searchParams 접근
      const params = url.searchParams;

      // 특정 파라미터 값 읽기
      console.log(params.get('query'));  // 출력: apple
      ```

3. error.js

- 주의
  - 같은 수준의 layout에서 에러가 발생할 경우 해당 error 컴포넌트로 이동하지 않는다.
    - <Layout><Error>{children}<Error><Layout> 구조로 layout이 더 상위이기 때문이다.
    - layout에서 발생하는 에러를 처리하고 싶다면 상위 컴포넌트의 error를 사용하거나, app의 루트 에러 처리를 담당하는 app/global-error.js 페이지를 생성하면 된다.

4. not-found.js

- 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다.

5. loading.js

- loading은 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.

6. route.js

- 디렉터리가 라우팅 주소를 담당하며 파일명은 route.js로 통일 됐다.
- `app/hello/route.ts` 파일 내부에 Rest API의 get, post와 같은 메서드명을 예약어로 선언해 두면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동한다.
  ```
  export async function GET(request: Request) {}
  ```
- app/api 외에 다른 곳에서 선언해도 작동한다.
- 주의
  - route.ts가 존재하는 폴더 내부에는 page.tsx가 존재 할 수 없다.

### 11.2 리액트에서의 서버 컴포넌트

#### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 브라우저의 렌더링
  - 리액트의 모든 코드는 클라이언트에서 작동하며, 브라우저에서 JS 코드 처리가 이뤄진다.
  - ex. 리액트로 만들어진 페이지를 방문한다고 가정했을때.
    - 웹사이트를 방문하면 브라우저가 리액트 실행에 필요한 코드를 다운로드하고 => 리액트 트리를 만든 다음 => DOM에 렌더링 합니다.
- SSR
  - 미리 서버에서 DOM을 만들어 오고 => 클라이언트에서는 이렇게 만들어진 DOM을 기준으로 하이드레이션을 진행한다. => 이후 브라우저에서는 상태를 추적하고 => 이벤트 핸들러를 DOM에 추가하고 => 응답에 따라 렌더링 트리를 변경하기도 한다.
- React와 Next.js에서 제공하는 SSR의 한계점

  1. JS 번들 크기가 0인 컴포넌트를 만들 수 없다.
     <details> 
     <summary>📍번들링</summary>
        JavaScript에서 "번들(bundle)"은 여러 개의 JavaScript 파일과 그와 관련된 리소스(예: CSS, 이미지 등)를 하나의 파일로 묶는 과정을 의미합니다. 번들링을 통해 애플리케이션의 성능을 최적화하고, 파일 로드 시간을 단축하며, 네트워크 요청의 수를 줄일 수 있습니다.

     - 번들링의 주요 이점

       1. 파일 크기 감소: 여러 파일을 하나로 합치고, 압축함으로써 전체 파일 크기를 줄일 수 있습니다.
       2. 네트워크 요청 감소: 여러 개의 파일을 하나로 합쳐 한 번에 로드하므로 네트워크 요청 횟수를 줄일 수 있습니다.
       3. 의존성 관리: 의존성 충돌을 방지하고, 모듈 간의 종속성을 체계적으로 관리할 수 있습니다.
       4. 캐싱 효율성 증가: 번들된 파일을 캐시하면 브라우저가 동일한 파일을 다시 다운로드할 필요가 없습니다.

     - 대표적인 번들러 도구로는 Webpack, Rollup, Parcel 등이 있으며, 이 도구들은 프로젝트의 구조와 요구 사항에 맞게 번들링을 자동화하고 최적화해줍니다.

     - 이러한 번들러들은 또한 트리 쉐이킹(tree shaking) 같은 최적화 기법을 사용하여, 실제로 사용되지 않는 코드(죽은 코드)를 제거함으로써 번들 파일의 크기를 더욱 줄여줍니다.

     </details>

  2. 백엔드 리소스에 대한 직접적인 접근이 불가하다.
  3. **자동** 코드 분할이 불가능하다.

  - 코드 분할이란 코드를 여러 작은 단위로 나누어 필요할 때만 동적으로 지연함으로써 앱을 초기화하는 속도를 높여주는 기법을 말합니다.
  - lazy를 사용하여 가능하지만, 일일이 lazy로 감싸야 한다는 번거로움과 코드 분할을 해도 되는 컴포넌트인지 유념하고 개발해야 하기 때문에 이를 누락하는 경우가 발생할 수 있다.

  4. 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
  5. 추상화에 드는 비용이 증가한다.

- **정리**
  - CSR
    - 사용자의 인터렉션에 따라 다양한 것들을 제공할 수 있다. 하지만 서버에 비해 느리고 데이터를 가져오기 어렵다.
  - SSR
    - 응답받은 페이지 전체를 HTML로 렌더링하는 과정(DOM을 만든다)을 서버에서 수행한 후, 그 결과를 클라이언트에 내려준다. => 이후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업을 수행한다.
      - SSR의 목적 : 초기에 인터렉션은 불가능하지만(JS가 없기 때문에) 정적인 HTML을 빠르게 내려주는 데 초점을 두고 있다.
        => 따라서 여전히 초기 HTML이 로딩된 이후에는 클라이언트에서 JS 코드를 다운로드하고, 파싱하고, 실행하는 데 비용이 든다.
    - 정적 콘텐츠를 빠르게 제공하고, 서버에 있는 데이터에 손쉽게 제공할 수 있다.
  - 이러한 두 구조의 장점을 모두 취하고자 하는 것이 바로 리액트 서버 컴포넌트이다.

#### 11.2.2 서버 컴포넌트

- ⭐️ 서버 컴포넌트 이론이란?
  - `하나의 언어`, `하나의 프레임위크`, 그리고 `하나의 API와 개념`을 사용하면서, **서버와 클라이언트 모두**에서 **컴포넌트를 렌더링**할 수 있는 기법을 의미한다.
  - 서버가 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 나머지 작업은 클라이언트인 브라우저에서 수행된다.
  - 즉, 일부 컴포넌트는 클라이언트에서 렌더링되고, 일부 컴포넌트는 서버에서 렌더링된다.
  - ❗️주의
    - 클라이언트 컴포넌트는 서버 컴포넌트를 import 할수 없다.
    - 이유
      - 만약 클라이언트 컴포넌트가 서버 컴포넌트를 불러오게 된다면 클라이언트 컴포넌트는 서버 컴포넌트를 실행할 방법이 없기 때문에(서버 환경이 브라우저에는 존재하지 않으므로) 컴포넌트를 호출할 수 없다.
  - 정리
    - 서버 컴포넌트 이론에 따르면 모든 컴포넌트는 서버 컴포넌트가 될 수 있고 클라이언트 컴포넌트가 될 수 있다.
    - 어떻게 이런 구조가 가능한 것일까?
      - `children으로 자주 사용되는 ReactNode에 달려 있다.`
- 경우의 수 (1.서버 컴포넌트 2.클라이언트 컴포넌트 3.공유 컴포넌트)

  1. 서버 컴포넌트

     - 요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐이므로 상태를 가질 수 없다. 따라서 리액트에서 상태를 가질 수 있는 useState, useReducer 등의 훅을 사용할 수 없다.
     - 렌더링 생명주기도 사용할 수 없다. 한번 렌더링되면 그걸로 끝이기 때문이다. => useEffect, useLayoutEffect를 사용할 수 없다.
     - 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 DOM API를 쓰거나 window,document 등에 접근할 수 없다.
     - db, 내부 서비스, 파일 시스템 등 서버에서만 있는 데이터를 async/await 으로 접근할 수 있다. 컴포넌트 자체가 async(비동기)한 것이 가능하다.

  2. 클라이언트 컴포넌트

     - 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없다.

       > - 클라이언트 컴포넌트가 서버 컴포넌트를 불러올 수 없다.
       > - 클라이언트 컴포넌트는 서버 컴포넌트를 children props로 받는 것만 가능하다.
       > - 서버 컴포넌트는 다른 서버 컴포넌트를 렌더링할 수 있다.
       > - 서버 컴포넌트는 다른 클라이언트 컴포넌트를 불러와 렌더링 할 수 있다.
       > - 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다. (공용 컴포넌트)
       >   - 이유 : 클라이언트 입장에서 봤을 때 서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있을 것이고(`ParentServerComponent`가 렌더링 될 때 트리가 만들어 진다.), 클라이언트 컴포넌트는 이미 서버에서 만들어진 트리를 삽입해서 보여주기만 하기 때문이다.

       ```
       // 공용 컴포넌트
       import ClientComponent from './ClientComponent'
       import ServerComponent from './ServerComponent'

       export default function ParentServerComponent() {
         return (
           <ClientComponent>
             <ServerComponent/>
           </ClientComponent>
         )
       }
       ```

  3. 공용 컴포넌트

  - 이 컴포넌트는 서버와 클라이언트 모두에서 사용할 수 있다.
  - 공통으로 사용할 수 있는 만큼, 서버 컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 된다.

- **리액트는 어떻게 서버 컴포넌트인지, 클라이언트 컴포넌트인지, 공용 컴포넌트인지 판단할까?**
  - 리액트는 모든 것을 다 공용 컴포넌트로 판단한다. 즉, 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류한다. 대신 클라이언트 컴포넌트라는 것을 명시적으로 선언하려면 파일의 맨 첫 줄에 `"use client"` 라고 작성해 두면 된다.

#### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 둘은 대체제가 아닌 상호보완하는 개념이다.

#### 11.2.4 리액트에서 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다. 즉, 루트에 있는 컴포넌트는 항상 서버 컴포넌트다. 예를 들어, '/react' 라고 한느 주소로 요청을 보내면 서버는 브라우저의 요청을 받고 서버 렌더링을 시작한다.

2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화(serialize) 한다. 이때 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타낸다. 서버는 와이어 포맷 형태로 클라이언트에 **스트리밍**해 제공한다. 브라우저는 이후에 이 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행한다.

   > 와이어 포맷
   >
   > - 서버에서는 클라이언트에서 리액트 컴포넌트 트리 구성에 필요한 정보를 최대한 많이, 그리고 경제적인 포맷으로 클라이언트에 전달한다.
   >   M : M으로 시작하는 줄은 클라이언트 컴포넌트이다. 해당 함수를 렌더링하기 위해 필요한 정보가 어디(chunk)에 담겨 있는지 참조를 전달해 준다.
   >   S : Suspense를 의미한다.
   >   J : 서버에서 렌더링된 서버 컴포넌트이다. J0d은 App.server.js를 표현한 것임을 알수 있다.
   >   @1, @2 : 나중에 렌더링 됐을 때 들어가야 할 컴포넌트를 의미한다. @1은 M1이 렌더링되면 저 @1 자리에 @M1이 들어가야 한다는 것을 의미한다.

   ```
   // 서버가 렌더링 요청을 보냈을 때 클라이언트에 보내는 값
   // 와이어 포맷(wire format)
   [
     "$",
     "section",
     null,
     {
       "className": "sidebar-menu",
       "role": "member",
       "children": [
         ["$", "@1", null, {}],
         [
           "$",
           "@2",
           null,
           {
             "notedId": null,
             "children": New
           }
         ]
       ]
     }
   ]
   ```

3. 브라우저가 리액트 컴포넌트 트리를 구성한다. (브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만든다. M1과 같은 형태의 클라이언트 컴포넌트를 받았다면 클라이언트에서 렌더링을 진행할 것이고, 서버에서 만들어진 결과물을 받았다면 이 정보를 기반으로 리엑트 트리를 그대로 만들 것이다.) 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋한다.

- **리액트 서버 컴포넌트 작동 방식의 특별한 점**
  - 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄으로써 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있어 브라우저에서는 되도록 빨리 사용자에게 결과물을 보여줄 수 있는 장점이 있다.
  - 각 컴포넌트의 번들링이 별개로 되어 있어 필요에 따라서 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능해졌다.
  - **SSR 과 다르게** 결과물이 HTML이 아닌 JSON 형태로 보내진다. 클라이언트의 최종 목표는 리액트 컴포넌트 트리를 서버 컴포넌트와 클라이언트 컴포넌트 두 가지로 조화롭게 구성하는 것으로, 이는 단순히 HTML을 그리는 작업이상의 일을 필요로 한다. 따라서 HTML 대신 단순 한리액트 컴포넌트 구조를 JSON으로 받아서 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있게 한다.

### 11.3 Next.js에서의 리액트 서버 컴포넌트

- 기본적으로 Next.js의 서버 컴포넌트의 제약은 React와 동일하다.
  - 서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수 없으며, 클라이언트 컴포넌트는 서버 컴포넌트를 props로 받는 것만 가능하다.
- React에서는 루트 컴포넌트는 무조건 서버 컴포넌트가 됐었는데, Next.js의 루트 컴포넌트는 각 페이지에 존재하는 page.js다.
- page.js와 layout.js는 반드시 서버 컴포넌트여야 한다.

```
// page.js
import ClientComponent from './ClientComponent'
import ServerComponent from './ServerComponent'

// 각 페이지는 기본으로 서버 컴포넌트로 작동한다.
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}

```

- 위 처럼 하면 클라이언트 컴포넌트 관점에서 서버 컴포넌트는 이미 렌더링된 결과물로 children에 들어갈 것이기 때문에 서버 컴포넌트 구조를 구축하는 데 문제가 없다.

#### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- **getServerSideProps, getStaticProps, getInitialProps** 가 /app 디렉터리 내부에서 삭제됐다. 그 대신 모든 데이터 요청은 웹에서 제공하는 표준 API인 **fetch**를 기반으로 이뤄진다.
- 서버 컴포넌트는 데이터가 불러오기 전까지 기다렸다가 데이터가 불러와지면 비로소 페이지가 렌더링되어 클라이언트로 전달될 것이다.
- 추가로 같은 서버 컴포넌트 트리 내에서 동일한 요청이 있다면 재요청이 발생하지 않도록 요청 중복을 방지할 수 있다.
  - SWR과 React Query와 비슷하게, 해당 fetch 요청에 대한 내용을 서버에서는 렌더링이 한 번 끝날 때까지 캐싱하며, 클라이언트에서는 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

#### 11.3.2 정적 렌더링과 동적 렌더링

- Next.js 13 에서는

  - 정적 라우팅 : 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재 사용할 수 있게끔 해둔다.
  - 동적 라우팅 : 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링한다.

- 정적 라우팅

  - 주소가 정적으로 결정되어 있다는 것은 `https://www.youtube.com/warch:${id}`와 달리 `https://www.youtube.com/` 와 같이 변하지 않은 주소를 의미한다.
  - 정적으로 결정돼 있기 때문에 빌드 시에 해당 주소로 미리 요청을 해서 데이터를 가져온 다음 렌더링을 한 결과를 빌드에 넣어준다.
  - 코드를 빌드한 결과물을 .next에서 확인하면 미리 제공하기 위한 test.html이 해당 API의 결과물과 함께 생성돼 있는 것을 볼 수 있다.
  - `fetch`에 `{ cache: 'no-cache' }` 옵션을 달면 캐싱하지 않겠다는 의미로 Next.js는 해당 요청을 미리 빌드해서 대기시켜 두지 않고 요청이 올때 마다 fetch 요청 이후에 렌더링을 수행하게 된다.
  - 만약 동적인 주소이지만 특정 주소에 대해서 캐싱하고 싶은 경우, `generateStaticParams`를 사용하면 된다.

    > fetch 옵션
    >
    > - `fetch(URL, { cache: 'force-cache' })`
    >   기본값으로 불러온 데이터를 캐싱해 해당 데이터로만 관리한다.
    > - `fetch(URL, { cache: 'no-store' })`, `fetch(URL, { next: { revalidate: 0 } })`
    >   캐싱하지 않고 매번 새로운 데이터를 불러온다.
    > - `fetch(URL, { revalidate: 10 })`
    >   정해진 유효시간 동안에는 캐싱하고, 이 유효시간이 지나면 캐시를 파기한다.

- revalidate 값이 설정된 경우에 캐시와 갱신이 이뤄지는 과정
  1. 최초로 해당 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여준다.
  2. 이 캐시된 초기 요청은 revalidate에 선언된 값 만큰 유지된다.
  3. 만약 해당 시간이 지나도 일단은 캐시된 데이터를 보여준다.
  4. Next.js는 캐시된 데이터를 보여주는 한편, 시간이 경과했으므로 백그라운드에서 다시 데이터를 불러온다.
  5. 4번의 작업이 성공적으로 끝나면 캐시된 데이터를 갱신하고, 그렇지 않으면 과거 데이터를 보여준다.
  - ❗️캐시를 전체적으로 무효화 하고 싶다면 router에 추가된 refresh 메서드로 `router.refresh();`를 사용하면 된다.
    => 이는 브라우저를 새로고침하는 등 브라우저의 히스토리에 영향을 미치지 않고, 오로지 서버에서 루트부터 데이터를 전체적으로 가져와서 갱신한다.
    브러우저나 리액트의 state에는 영향을 미치지 않는다.

#### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

- SSR
  - 요청받은 페이지를 모두 렌더링해서 내려줄 때 까지는 사용자에게 아무것도 보여 줄 수 없어 사용자는 빈 페이지만 보게 된다.
  - 페이지를 다 받았다고 해도 사용자가 인터렉션 할 수 없는 정적 페이지이다.
  - 문제는 이 작업이 순차적으로 다 완료돼야만 페이지 하나를 온전하게 볼 수 있다는 것이다.
  - 이를 해결하기 위해 **스트리밍**이 도입됐다.
- server component

  - **스트리밍**은 페이지가 다 완성될 때 까지 기다리는 것이 아니라 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 방식이다.
  - 스트리밍을 사용하면 먼저 로드되는 데이터를 바로 바로 보내 주기 때문에 사용자가 일부라도 빨리 페이지와 인터렉션을 할 수 있다.
  - 이로 인해 페이지가 로딩 중이라는 인식을 더 명확하게 심어줄 수 있다.
  - 스트리밍을 활용할 수 있는 2가지 방법

    1. 경로에 loading.tsx 배치

    - 아래 코드와 같이 suspense와 함께 사용한다.

      - 페이지 전체의 로딩 상황에 대해 loading.tsx 파일의 로딩 컴포넌트가 적용된다.

        ```
        <Suspense fallback={<Loading />}>
          <Page />
        </Suspense>
        ```

    2. suspense 배치

    - 좀 더 세분화 된 제어를 하고 싶다면 직접 리액의의 suspense를 페이지의 각각의 컴포넌트에 적용하는 것도 가능하다.

      ```
      import { Suspense } from 'react'
      import { Notes, Peoples } from './Components'

      export default function Posts() {
        return (
          <section>
            <Suspense fallback={<Skeleton />}>
              <Notes />
            </Suspense>
            <Suspense fallback={<Skeleton />}>
              <Peoples />
            </Suspense>
          </section>
        )
      }

      ```

- 정리
  - 서버 컴포넌트는 스트리밍을 활용해 서버에서 렌더링이 가능해지고, 리액트는 로딩이 끝난 컴포넌트 순서대로 하이드레이션을 수행해 가능한 한 사용자에게 빠르게 상호작용이 가능한 페이지를 제공할 수 있게 된다.

### 11.4 웹팩의 대항마, 터보팩의 등장 (beta)

- Next.js 13에서 부터 웹팩의 후계자
- 러스트로 작성되었기 때문에 웹팩 보다 최대 700배, Vite 보다 10배 빠르다.

### 11.5 서버 액션 (alpha)

#### 11.5.1 form action

- `server action`을 만들려면

  - 함수 내부 또는 파일 상단에 클라이언트 선언과 비슷하게 `use server` 지시자를 선언해야 한다.
    - `use server` 를 사용하게 되면 서버에 바로 접근 가능해 진다.
    - `use server` 내의 작업은 서버에서 이루어지기 때문에 CORS 이슈가 따로 없다.
  - 함수는 반드시 `async` 여야 한다.

- form에 action props를 추가하여 server action 함수를 form에 연결할 수 있다.

```
async function handleSubmit() {
  'use server'
  ...fetch logic
}


<form action={handleSubmit}>
  <button type="submit"></button>
</form>
```

- handleSubmit이 이벤트를 발생시키는 것은 클라이언트지만 실제로 함수 자체가 수행되는 것은 서버이다.

  - /server-action/form 으로 요청이 수행된다.

- server action의 장점은 폼과 실제 노출되는 데이터가 연동돼 있을 때 더욱 효과적으로 사용할 수 있다.

  - 최초에 페이지를 서버에서 렌더링한 이후에 폼에서 handleSubmit으로 서버에 데이터 수정을 요청 => 수정된 결과를 다시 조회해서 새로운 결과로 렌더링하는 일련의 과정이 모두 페이지 새로고침 없이 데이터 스트리밍으로 이뤄진다. (server mutation)

    > php : 서버 기반 웹 애플리케이션

- server mutation(서버에서의 데이터 수정)
  - server mutation으로 실행할 수 있는 함수
    1.redirect 2.revalidatePath 3.revalidateTag

#### 11.5.2 input의 submit과 image의 formAction

- form.action과 마찬가지로 input type="submit" 또는 input type="image" 에 formAction prop 으로도 서버액션을 추가 할 수 있다.

#### 11.5.3 startTransition과의 연동

서버 액션은 useTransition에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있다.

#### 11.5.4 server mutation이 없는 작업

server mutation이 필요없다면 반드시 서버 액션을 useTransition과 함께 사용해야 하지만 별도의 server mutation을 실행하지 않는다면 바로 이벤트 헨들러에 넣어도 된다.

#### 11.5.5 서버 액션 사용 시 주의할 점

- 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없다.
- 서버 액션을 import 하는 것 뿐만 아니라, props 형태로 서버 액션을 클라이언트 컴포넌트에 넘기는 것 또한 가능하다.

### 11.6 그 밖의 변화

- 프로 젝트 전체 라우트에서 쓸 수 있는 미들웨어가 강화됐다.
- SEO를 쉽게 작성할 수 있는 기능이 추가 됐다.
- 정적으로 내부 링크를 분석할 수 있는 기능 등 다양한 내용이 추가 됐다.

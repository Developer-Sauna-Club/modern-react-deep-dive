### 상태 관리는 왜 필요한가?

#### 상태란?

- 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경 될 수 있는 값이다.
- 웹 어플리케이션에서의 상태 분류
  - UI
    - 상호 작용이 가능한 모든 요소의 현재 값
    - ex. 알림차의 노출 여부, 다크/라이트 모드
  - URL
    - 브라우저에서 관리되고 있는 상태 값
    - https://www.airbnb.co.kr/rooms/12345?adults=2
    - 위의 예시의 경우 `roomId=12345` `adults=2`상태가 존재한다.
  - 폼(form)
    - 폼에도 로딩 중인인지(loading), 현재 제출됐는지(submit), 접근이 불가능한지(disabled), 값이 유효한지(validation) 등 모두가 상태로 관리된다.
  - 서버에서 가져온 값
    - 클라이언트에서 서버로 요청을 통해 가져온 값도 상태이다.
    - ex. API 요청 값

#### 리액트에서의 상태 관리 (특히 전역 상태 관리)

- 리덕스 이전에는 딱히 상태 관리 라이브러리가 없었다.
- 이때의 상황은 웹 애플리케이션이 커지고, 상태(데이터)도 많아짐에 따라 상태 변화를 추적하고 이해하기 어려운 상황이었다.
- 이때는 MVC 패턴은 사용하고 있었다.
  - MVC 패턴의 문제점을 양방향 데이터 바이딩으로 보고 단방향 데이터 흐름인 FLUX를 패턴을 도입했다.
    `Action => Dispatcher => Model => View`
    - Action : 어떤 작업을 처리할 액션과 액션 발생 시 포함시킬 데이터
    - Dispatcher : 액션을 스토어에 보내는 역할을 한다.
    - Store : 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다.
    - View : 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다.

#### Redux

- FLUX 구조를 구현하기 위한 라이브러리 중 하나인데 특별한 것은 Elm 아키텍처를 도입했다는 점이다.

- Elm 아키텍쳐의 핵심 3가지

  - model
    - 애플리케이션의 상태를 의미한다.
  - view
    - 모델의 표현하는 HTML을 의미한다.
  - update
    - 모델을 수정하는 방식을 말한다.

- 즉, Elm은 FLUX와 마찬가지로 데이터 흐름을 3가지로 분류하고, 이를 단방향으로 강제해 웹 애플리케이션의 상태를 관리한다.
  <img src="./img/Screenshot 2024-05-10 at 5.17.48 PM.png" />

  - state : store에 저장되어 있는 값
  - action : store에 저장된 값을 변경시키는 방식
  - reducer : action + old state를 받아서 new state로 변환시키는 함수.
  - store : state들이 저장된다.

  - `예시 코드`
    버튼을 클릭하면 => dispatch 함수가 increment 액션을 store에 전달 => store는 이 액션을 reducer에 전달하여 현재 상태를 기반으로 새로운 상태를 계산 => 이 새로운 상태를 저장하고 관련된 컴포넌트에 상태 변경을 반영한다.

#### Recoil

- 리액트를 위한 상태 관리 라이브러리이다.
- 아직까지도 실험단계이다.
- 최소 상태 개념인 Atom을 처음으로 선보였다.
  - atom은 상태를 나타내는 recoil의 최소 상태 단위이다.
  - key 값을 필수로 가지며, 이 키는 다른 atom과 구별하는 식별자로 필수 값이다.
- Recoil의 중요 특징

  1. Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
  2. 스토어의 상태값에 접근할 수 있는 함수들이 있고 이 함수를 통해 상태값에 접근하거나 상태값을 변경할 수 있다.
  3. 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.

- `예시 코드`

  - atom을 사용하여 상태를 저장하고, useRecoilState를 사용하여 상태를 읽고 업데이트한다.

- selector을 필두로 다양한 비동기 작업을 지원하는 API를 제공하고 있기 때문에 리덕스와 달리 redux-saga나 redux-thunk 등 추가적인 미들웨어를 사용하지 않더라도 비동기 작업을 수월하게 처리할 수 있다. 하지만 정식 버전이 아직 출시 되지 않고 있다는 걸림돌이 있다.

#### Jotai

- Recoil의 atom 모델에 영감을 받아 만들어진 상태 관리 라이브러리다.
- 상향식 접근법으로 작은 단위의 상태를 위로 전파할 수 있는 구조를 취하고 있다.
- React Context의 문제점인 불필요한 리렌더링이 일어난다는 문제를 해결하고자 설계돼 있다.
- atom 개념이 존재한다.

  - Recoil과 마찬가지로 최소 단위 상태를 의미한다.
  - Recoil과 다르게, atom 하나만으로 상태를 만들 수도, 이에 파생된 상태를 만들 수도 있다.

- `예시 코드` 2개
  - atom 개념을 도입하면서 API가 간결하다.
  - recoild의 atom에서는 각 상태값이 모두 별도의 키를 필요했는데, jotai는 이 부분을 추상화해 사용자가 키를 관리할 필요없다. => 객체의 참조를 통해 값을 관리한다.
  - recoil에서 처럼 selector 없이도 atom 값에서 또 다른 파생된 상태를 만들수 있다.

#### Zustand

- Zustand는 리덕스에 영감을 받아 만들어졌다.
- 하나의 store를 중앙 집중형으로 활용해, store에서 상태를 관리한다.

- `예시 코드`

- 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있는 큰 장점이 있다.

#### 상태 관리 라이브러리 선택법

- 라이브러리별로 특징을 잘 파악해서 상황에 맞는 라이브러리를 선택하자
- 메인테이너가 많고 다운로드가 활발하며 이슈가 관리가 잘되고 있는 라이브러리를 선택한는 것이 좋다.

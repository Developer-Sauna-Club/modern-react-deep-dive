- 서버사이드렌더링이란?
  - 최초에 사용자에게 보여줄 페이지를 **서버에서 렌더링**해 빠르게 사용자에게 화면을 제공하는 방식
  - cf. 싱글페이지 애플리케이션은 자바스크립트를 활용해 하나의 페이지에서만 렌더링
    - 렌더링, 라우팅에 필요한 대부분의 기능을 **브라우저의 JS가 수행** (ex. `history.pushState`, `history.replaceState`)
  - JAM 스택 vs. LAMP 스택
    - LAMP스택: 과거에 인기있던 웹 개발 구조, 어쩔 수 없는 선택 (JS가 할 수 있는 일이 많지 않아 서버가 대부분의 기능을 처리). 사용자가 많아지고 웹을 확장하려면 서버도 확장해야 해 번거로웠다.
    - JAM 스택: 프론트엔드는 JS, 마크업만 빌드해두고 정적으로 사용자에게 제공하면 이후 동작은 클라이언트에서 실행 - 서버로부터 조금 더 자유로워졌다. Node.js도 고도화되면서 API 서버도 JS로 구현하는 구조가 인기를 끌기 시작
    - SPA가 유행하면서 JAM 스택이 인기
  - 다시 SSR이 유행하게 된 배경 (필요성)
    - SPA를 채택하더라도 사용자의 기기나 인터넷 환경에 따라 사이트의 속도가 달라진다.
    - 웹 애플리케이션에서 제공하는 자바스크립트 리소스의 크기가 증가했다. -> 속도도 느려졌다.
  - SSR의 장점
    - 최초 페이지 진입이 빠르다. (즉, FCP - First Contentful Paint가 더 빨라질 수 있다.)
      - **화면에 표시할 정보가 외부 API 호출에 많이 의존적인 경우**, 서버에서 HTTP 요청을 보내는 게 더 빠르기 때문에 더 빠르게 렌더링이 가능할 수 있다.
      - 서버에서 HTML을 문자열로 미리 그려 전달하는 것이 클라이언트에서 기존 HTML에 삽입하는 시간보다 더 빠르다. 따라서 렌더링할 **HTML의 크기가 큰 경우** 유리하다.
    - 검색 엔진 최적화(SEO)에 유리하다.
      - 검색 엔진 로봇이 페이지 진입했을 때 자바스크립트를 실행하지 않고 HTML만 다운받기 때문에 SPA는 메타 정보를 별도로 제공할 조치를 취해야 한다.
    - 누적 레이아웃 이동(Cumulative Layout Shift)이 적다.
      - SPA의 경우 특정 영역만 로딩이 느려진다면 그 영역만큼이 화면에서 나중에 렌더링되면서 화면이 움직이는 것처럼 보이는 불편함을 초래한다.
      - SSR은 요청이 전부 완료된 후에 완성된 페이지를 제공하기 때문에 비교적 자유롭다.
      - 단, useEffect는 마운트 이후에 실행되므로 SSR, SPA모두 문제의 소지가 있다.
    - 사용자 디바이스 성능으로부터 비교적 자유롭다.
      - 렌더링 부담을 서버에 나눌 수 있기 때문에 비교적 자유롭다.
      - 다만 인터넷 속도가 느리거나 사용자 방문이 폭증해 서버 부담이 가중되면 SSR 역시 느려질 수 있다.
    - 보안에 좀 더 안전하다.
      - JAM 스택 프로젝트는 애플리케이션 내용이 브라우저에 노출되기 때문에 별도의 조치를 취해야 한다.
  - SSR의 단점
    - 개발 시 항상 서버를 고려해야 하는 불편함
      - 브라우저 전역 객체인 window, sessinStorage 등 접근 불가
    - 적절한 서버 구축
      - 물리적인 가용량을 확보
      - 장애 상황 대처하는 복구 전략
      - 요청 분산, 프로세스 매니저 필요
    - 서비스 지연이 발생할 경우 어떤 정보도 제공할 수 없다.
      - SPA는 로딩 중을 표시할 수라도 있는데..
  - 가장 뛰어난 SPA > 가장 뛰어난 MPA
    - SPA에서 최적화를 잘 거쳤다면 매끄러운 라우팅으로 뛰어난 성능.
  - 평균적인 SPA < 평균적인 MPA
    - SPA는 렌더링과 라우팅에 별도의 최적화를 거쳐야 하지만, MPA는 각 페이지마다 서버에서 렌더링하기 때문에.
- 서버사이드렌더링을 위한 리액트 API
  - [`react-dom/server.js`](https://github.com/facebook/react/blob/main/packages/react-dom/server.js)
    - 클라이언트에서 실행되는 JS코드를 포함하거나 렌더링해주지는 않는다. -> 초기 렌더링에 이점
    - `renderToString`
      - 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환
      - `data-reactroot`속성: 리액트 컴포넌트의 root 엘리먼트가 무엇인지 식별
        - hydrate 함수에서 루트를 식별하는 기준이 된다.
    - `renderToStaticMarkup`
      - `renderToString`과 동일한 역할
      - `data-reactroot`과 같이 리액트에서만 사용하는 속성을 만들지 않는다. → hydrate할 필요가 없는 경우 `renderToStaticMarkup`을 사용하면 HTML크기를 약간이나마 줄일 수 있다.
        - hydrate를 수행해도 클라이언트에서 완전히 새롭게 렌더링하기 때문에 서버와 클라이언트가 내용이 맞지 않는다는 에러가 발생한다.
    - `renderToNodeStream`
      - `renderToString`과 동일하지만 `renderToNodeStream`은 브라우저에서 사용할 수 없다. Node.js 서버환경에서만 사용 가능.
      - `스트림`: 큰 데이터를 다룰 때 데이터를 청크로 분할해 조금씩 가져오는 방식
      - `renderToString`으로 생성해야 하는 HTML의 크기가 매우 큰 경우 유용 → 유명한 프레임워크들은 다 `renderToString`이 아닌 `renderToNodeStream`채택
    - `renderToStaticNodeStream`
      - `renderToNodeStream`과 동일하되 hydrate할 필요 없는 경우 사용
    - `hydrate`
      - `renderToString`, `renderToNodeStream`으로 생성된 HTML에 자바스크립트 핸들러나 이벤트 붙이는 역할
      - 서버가 렌더링해 제공해준 HTML을 기준으로 이벤트를 붙이는 작업만 실행
      - 서버가 제공하는 HTML이 클라이언트의 결과물과 같다는 전제 하에 실행
- Next.js
  - 구조
    - `pages/_app.tsx`
      - 애플리케이션 전체 페이지의 시작점
      - 공통으로 설정해야 한느 내용을 여기에서 실행
      - 렌더링이나 라우팅에 따라 서버 또는 클라이언트에서 실행
    - `pages/_document.tsx`
      - 애플리케이션의 HTML을 초기화 - HTML 설정과 관련된 코드 추가
      - 무조건 서버에서 실행
      - CSS-in-JS의 스타일을 서버에서 모아 HTML로 제공 가능
      - 없어도 지장 없는 파일
    - `pages/_error.tsx`
      - 프로젝트 전역에서 발생하는 에러 처리하기 위한 페이지
      - 없어도 지장 없는 파일
    - `pages/404.tsx`
      - 만들지 않으면 Next.js 기본 제공 404페이지
    - `pages/500.tsx`
      - `_error.tsx`도 있는 경우 `500.tsx`가 우선적으로 실행
      - 만들지 않으면 기본 제공 에러 페이지
    - `pages/index.tsx`
      - 개발자가 자유롭게 명칭 지정해 만들 수 있는 페이지 (라우팅이 파일명으로 이어지는 구조, react-pages 프로젝트에서부터 시작)
      - `/pages/hi/[변수].tsx` - [ ]안에 어떤 값이든 가능
      - `/pages/hi/[...변수].tsx` - /hi의 모든 하위 주소가 props 변수에 배열로
  - 서버 라우팅 vs. 클라이언트 라우팅
    - Next.js는 SSR을 수행하지만 클라이언트 라우팅도 수행 - 두 방식 혼재
    - next/link가 제공하는 `<Link>`: 클라이언트에서 필요한 자바스크립트만 불러온 뒤 라우팅하는 클라이언트 라우팅/렌더링 방식으로 작동
      - 따라서 최초에는 SSR로 작동하여 빠르게 페이지를 보고, 이후 링크 이동 시에는 `<Link>`를 사용해 매끄럽게 화면 전환이 가능하다.
      - `<a>` 대신 `<Link>`를 사용하자.
      - `window.location.push` 대신 `router.push`를 사용하자.
  - `getServerSideProps`가 존재하는 이유
    - 없으면 서버에서 실행하지 않아도 되는 페이지로 처리
  - `pages/api` 활용 방법
    - 서버에서 내려주는 데이터를 조합해 Backend-for-Frontend 형태로 활용하고 싶을 때
    - 완전한 풀스택 애플리케이션을 구축하고 싶을 때
    - CORS 문제를 우회하고 싶을 때
  - Data Fetching
    - ssr을 지원하기 위한 몇 가지 데이터 불러오기 전략
    - 라우팅 되는 파일에서만 사용 가능
    - 예약어로 지정되어 정해진 함수명으로 export해야 함
    - 페이지 요청이 있을 때마다 서버에서 데이터를 조회해 미리 페이지 만들어 제공 가능
    - `getStaticPaths`, `getStaticProps`
      - 정적인 페이지 보여줄 때
      - `getStaticPaths`: 접근 가능한 주소를 정의
      - `getStaticProps`: 정의한 페이지로 요청이 왔을 때 제공할 props 반환
      - **빌드 시점**에 미리 데이터를 불러온 다음에 정적인 HTML 페이지 만듦 → 페이지 렌더링을 기다릴 필요 없이 이미 완성된 페이지를 받기만 하면 되므로 빠르게 페이지 확인 가능
    - `getServerSideProps`
      - 페이지 진입 전에 서버에서 이 함수 실행, 응답에 따라 페이지의 루트 컴포넌트에 **props를 제공**하거나 다른 페이지로 리다이렉트 시킬 수도
      - 무조건 서버에서**만** 실행된다.
        - 페이지에 이 함수가 있다면 꼭 서버에서 실행해야 하는 페이지로 분류된다.
        - 클라이언트에서 실행되는 함수 등은 별도로 처리해줘야 한다.
      - `getServerSideProps`가 반환하는 값을 props로 제공해 서버에서 HTML 렌더링
      - `__NEXT_DATA__` id가 지정된 script(`getServerSideProps`의 정보인 props, 현재 페이지 정보 등 다양한 정보 포함)를 HTML에 삽입한다.
        - script 형태로 삽입된 이유: 서버에서 렌더링하기 전에 렌더링에 필요해 가져왔던 외부 데이터를 hydrate할 때 클라이언트에서 그대로 사용할 수 있도록 script에 저장해둔다. 따라서 hydrate 시 데이터를 재요청할 필요 없이 해당 script만 읽으면 '동일한'(재요청을 하지 않아 시차로 인한 데이터 변화가 없음) 데이터를 그대로 가져올 수 있다.
      - `getServerSideProps`의 props로 내려줄 수 있는 값은 JSON으로 제공할 수 있는 값이어야 한다.
      - 이 실행이 끝나기 전에는 사용자에게 어떠한 화면도 보여줄 수 없기 때문에 꼭 최초에 보여줘야 하는 데이터만 포함해 최대한 간결하게 작성하는 것이 좋다.
      - **리다이렉트**를 처리한다.
        - 클라이언트에서 리다이렉트를 처리하면 자바스크립트가 어느 정도 로딩된 후에 (화면이 어느 정도 보여진 후에)실행되지만, 서버에서 처리하면 페이지를 보여주기도 전에 미리 리다이렉트 시키므로 사용자에게 훨씬 매끄럽다.
    - `getInitialProps`
      - 현재는 권장되지 않음, `getStaticProps`, `getServerSideProps`가 나오기 전에 사용할 수 있었던 유일한 페이지 데이터 불러오기 수단
      - `_app.tsx`나 `_error.tsx`처럼 Next.js 특성 상 사용이 제한돼 있는 페이지에서만 사용하자.
  - 스타일 적용 방식
    - 전역 스타일
      - `_app.tsx`에 css import
    - 컴포넌트 레벨 CSS
      - `[이름].module.css`에 작성
      - Next.js가 컴포넌트별 클래스 이름 충돌을 방지하기 위해 클래스명을 최적화함.
    - SCSS와 SASS
      - CSS 작성과 동일
    - CSS-in-JS
      - ex) styled-jsx, **styled-components**, Emotion, Linaria, ...
      - `_document.tsx`에서 스타일을 모은 다음 서버사이드렌더링에서 한꺼번에 제공하는 초기화 코드를 추가해야 한다.
        - 안 그러면 스타일이 브라우저에 뒤늦게 추가되어 FOUC(flash of unstyled content)가 잠깐 노출돼버린다.
  - `_app.tsx`응용하기
    - 사이트에 최초로 접속했을 때만 실행하고 싶은 내용을 `app.getInitialProps`내부에 담아둘 수 있다.
    - userAgent나 사용자 정보와 같은 애플리케이션 전역에서 사용해야 하는 정보 등을 호출하는 작업을 수행하고자 할 때 활용할 수 있다.
  - `next.config.js`
    - `basePath`
    - `swcMinify`
    - `poweredByHeader`
    - `redirects`
    - `reactStrictMode`
    - `assetPrefix`

# 서버 사이드 렌더링

---

### 서버 사이드 렌더링

- [4.1. 서버 사이드 렌더링이란?](https://www.notion.so/200f0f7ac8fb4efca7594c297cd9fd16?pvs=21)
- 4.2. 서버 사이드 렌더링을 위한 리액트 API 살펴보기
- 4.3. Next.js 톺아보기

## 서버 사이드 렌더링이란?

---

> 리액트 개발자라면, 특히 다수의 사용자에게 좋은 사용자 경험을 제공할 수 있는 웹 애플리케이션을 만들고 싶은 개발자라면 두 가지 방법(CSR, SSR)을 모두 숙지할 필요가 있다.

왜 서버 사이드 렌더링이 각광받고 있는지 웹 세계의 현주소와 맥락을 따라가보자.

### **싱글 페이지 애플리케이션 세상**

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" width="40px" /> **싱글 페이지 애플리케이션 (SPA)**

---

렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식으로, 최초에 첫 페이지에서 데이터를 모두 불러온 이후에는 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 history.pushState와 history.replaceState로 이루어진다.

- 부드러운 사용자 경험과 빠른 반응 속도, 일관성 유지 등의 장점
- 많은 리소스를 한 번에 로드해야 하기에 초기 로딩이 길어지고, 클라이언트 측에서 상태를 관리하므로 코드가 복잡해지며, 자바스크립트에 의존하기에 브라우저 호환성 문제가 발생하는 단점
</aside>

**전통적인 방식의 애플리케이션과 SPA 작동 비교**

- 과거 서버 사이드에서 작동하던 전통적인 방식의 앱은 페이지 전환이 발생할 때마다 새롭게 페이지를 요청하고, HTML 페이지를 다운로드해 파싱해야 함
- 이 과정에서 페이지가 전환될 때 흰 화면이 잠시 노출되는 등의 부자연스러운 모습이 발생
- SPA는 최초 로딩 시간 이후에는 페이지 전환에 추가 리소스를 받을 필요가 없어짐
- 또한 경우에 따라 페이지 전체가 아니라 페이지 전환에 필요한 일부 영역만 렌더링하면 되므로 더 매끄러운 UI를 보여줄 수 있음

**싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장**

- 과거 PHP나 JSP 기반 웹이 유행이었을 때는 대부분 SSR로 동작, 자바스크립트는 어디까지나 사용자에게 추가적인 경험을 주기 위한 보조적인 수단으로 사용
  ⬇️
- 자바스크립트의 발전과 모듈화(CommonJS와 AMD), 사용자 기기의 성능 향상과 인터넷 속도의 발전으로 자바스크립트의 역할이 다양화
- 2010년 경 Backbone.js와 AngularJS, Knockout.js 등이 등장
- 자바스크립트에서 MVx 프레임워크를 구현, 어느 정도 서버에서만 할 수 있었던 복잡한 작업을 하기 시작 → React, Vue, Angular의 시대 도래
- SPA는 자바스크립트만 잘 작성하면 되어서 개발자에게 더 편리했으므로 폭발적으로 성장

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" width="40px" /> **JAM 스택 (Javascript, API, Markup)**

---

- 기존 웹 개발의 주축이었던 LAMP 스택(Linux, Apache, MySQL, PHP/Python)
- 위 스택의 서버 의존적인 문제는 웹앱의 확장성에 걸림돌이 되었고, 클라우드 개념이 부족했던 당시에는 서버 확장에도 어려움을 겪었음
- 앞서 언급한 프레임워크의 등장으로 대부분의 작업을 자바스크립트에서 수행할 수 있었기 때문에 서버 확장성에서 자유로워 졌음
- JAM 스택의 인기와 Node.js의 고도화에 힘입어 MEAN(MongoDB, Express.js, AngularJS, Node.js)이나 MERN(MongoDB, Express.js, React, Node.js) 스택처럼 API 서버 자체도 자바스크립트로 구현하는 구조가 인기를 끔
</aside>

**새로운 패러다임의 웹서비스를 향한 요구**

- 기기의 성능과 인터넷 속도는 날이 갈수록 빨라졌지만, 이와 맞추어 자바스크립트 리소스의 크기와 수 모두 증가하기 시작
- 하지만 웹페이지의 로딩 속도는 5년 전이나 지금이나 크게 차이가 없거나 오히려 더 느림

### 서버 사이드 렌더링이란?

웹페이지가 점점 느려지는 상황에 대해 SPA의 태생적 한계에서 문제 의식을 갖고, 기존 방식의 웹 개발(SSR)이 다시금 떠오르고 있는 상황이다.

**서버 사이드 렌더링의 장점**

- 비교적 최초 페이지 진입이 빠름
  일반적으로 서버에서 HTTP 요청을 수행하는 것이 더 빠르고, HTML을 그리는 작업도 서버에서 해당 HTML을 문자열로 미리 그려서 내려주는 것이 클라이언트에서 기존 HTML에 삽입하는 것보다 더 빠르다. 화면 렌더링이 HTTP 요청에 의존적이거나 렌더링해야 할 HTML의 크기가 커진다면 상대적으로 SSR이 더 빠를 수 있다.
- 비교적 유저 디바이스 성능에서 자유로움

  사용자 디바이스에서 실행되는 자바스크립트 리소스의 크기가 줄어드므로 비교적 디바이스 성능에서 자유롭다고 할 수 있다.

- 누적 레이아웃 이동(CLS)이 적음

  뒤늦게 HTML에 정보를 추가하거나 삭제하지 않으므로 화면이 덜컥거려 보이는 현상이 비교적 적다.

- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉬움

  검색 엔진이 사이트에서 필요한 정보를 가져가는 과정은 검색 엔진 로봇이 페이지에 진입하여 HTML을 다운로드하고 내부의 오픈 그래프나 메타 태그 정보를 기반으로 검색/공유 정보를 가져와 검색 엔진에 저장한다. 자바스크립트 코드는 실행하지 않기 때문에 메타 정보를 제공하도록 조치하지 않으면 페이지 노출에 불이익이 있다.

- 보안에 좀 더 안전함
  JAM 스택 프로젝트의 문제점은 앱의 모든 활동이 브라우저에 노출된다는 점이다. API 호출과 인증 같이 사용자에게 노출되서는 안되는 민감한 작업도 포함되므로 이를 신경써야만 했는데, SSR은 민감한 작업을 서버에서 수행하고 결과만 제공하여 보안 위협을 피할 수 있다.

**서버 사이드 렌더링의 단점**

- 소스 코드 작성 시 항상 서버를 고려해야 함
  가장 큰 문제는 브라우저 전역 객체인 window나 sessionStorage같은 객체를 사용할 수 없기 때문에 서버에서 실행될 수 있는 코드에서는 window 접근을 최소화해야 한다. 사용이 불가피한 경우 해당 코드가 서버 사이드에서 실행되지 않도록 처리해야 한다. 또한 외부 의존성 라이브러리도 서버에 대한 고려가 되어 있지 않으면 다른 대안을 찾거나 클라이언트에서 실행되도록 처리해야 하지만, 클라이언트에서 실행되는 코드가 많아질수록 SSR의 장점을 잃는다.
- 적절한 서버가 구축되어 있어야 함
  서버를 구축하는 것은 쉬운 일이 아니며, 물리적 가용량, 에러 대처 등의 복구 전략도 필요하다. 요청 분산, 프로세스 다운될 때를 대비도 필요하다. 여러 라이브러리 및 도구의 도움을 얻더라도 절대 쉽지 않은 일이다.
- 서비스 지연에 따른 문제가 발생할 수 있음
  SPA에서는 느린 작업이 있더라도 화면에 로딩 중임을 알리는 UI를 안내하면 사용자가 인내할 여지가 있으나, SSR에서 만약 최초 렌더링에 지연이 발생하면 사용자에게 어떤 정보도 제공할 수 없다는 문제가 발생한다. 다양한 요청에 얽혀 병목 현상이 심해지면 SSR이 더 안 좋은 사용자 경험을 제공할 수도 있다.

### SPA와 SSR을 모두 알아야 하는 이유

서버 사이드 렌더링은 만능이 아니며, 웹 페이지의 설계와 목적, 우선순위에 따라 SPA가 더 효율적일 가능성이 있다. SPA와 SSR 애플리케이션을 성능에 따라 비교해보자.

**가장 뛰어난 SPA > 가장 뛰어난 MPA**

- 최초 페이지 진입 시 보여줘야 할 정보만 최적화하여 요청해서 렌더링
- 이미지 같이 중요성이 떨어지는 리소스는 lazy loading으로 처리
- 코드 분할을 칼같이 해서 불필요한 js 리소스의 다운로드 및 실행을 방지

SSR 방식의 MPA가 엄청난 최적화를 하더라도, SPA 방식의 브라우저 API와 JS를 활용한 라우팅 기반의 매끄러운 라우팅보다 뛰어나진 못할 것이다.

**평균적인 SPA < 평균적인 MPA**

- 일반적 SPA에서 렌더링과 라우팅에 최적화가 되어있지 않다면 사용자 기기에 따라 성능이 들쑥날쑥할 것
- 매번 서버에 렌더링 요청을 하고, 안정적인 리소스 기반으로 매 요청을 비슷한 성능으로 렌더링하는 경우가 더 뛰어남
- 페이지 전환 시 필요한 리소스와 공통으로 사용하는 리소스를 분류하고 이에 따른 다운로드나 렌더링 우선순위 전략을 잘 수립하여 SPA를 최적화하기는 매우 어려운 작업
- 따라서 평균적인 노력으로 동일한 서비스를 만들 경우 MPA가 우세할 것
- 또한 최근 MPA에서 발생하는 라우팅으로 인한 문제를 해결하기 위한 다양한 API가 브라우저에 추가되고 있는 추세
  - `페인트 홀딩(Paint Holding)` : 같은 출처(origin)에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신에 이전 페이지의 모습을 잠깐 보여주는 기법
  - `bfcache(back forward chache)` : 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
  - `Shared Element Transitions` : 페이지 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법

두 방식 모두 장단점이 있으며 어느 하나 완벽하다 할 수 없으므로 두 방법론을 모두 알아야 할 필요가 있다.

### **현대의 서버 사이드 렌더링**

**기존 LAMP 스택**

- 모든 페이지 빌드를 서버에서 렌더링해 초기 페이지 진입이 빠르지만, 이후 라우팅이 발생할 때도 마찬가지로 서버에 의존해야 하기 때문에 SPA 방식에 비해 라우팅이 느림

**요즘의 서버 사이드 렌더링**

- SPA와 SSR의 장점을 모두 취한 방식으로 동작한다.
- 최초 웹사이트 진입 시에는 SSR 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 SPA처럼 작동함
- Next.js, Remix 등의 서버 사이드 렌더링 프레임워크들은 이러한 방식으로 작동하여 더 나은 웹사이트 경험을 제공함
- 때문에 서버 사이드 렌더링, 클라이언트 사이드 렌더링을 모두 이해해야 두 가지 장점을 완벽하게 취하는 웹사이트를 구축할 수 있음

## 서버 사이드 렌더링을 위한 리액트 API 살펴보기

---

리액트는 서버에서 렌더링할 수 있는 API도 제공한다. Node.js와 같은 서버 환경에서만 실행할 수 있으며 window 환경에서 실행 시 에러가 발생할 수 있다. 리액트 18이 릴리스되면서 react-dom/server에 rednerToPipeableStream이 추가되었고, 나머지는 deprecated되는 등 큰 변화를 거쳤다.

### renderToString

- **인수로 넘겨받은 리액트 컴포넌트를 HTML 문자열로 반환**
- 리액트 컴포넌트를 기준으로 빠르게 HTML을 제공하는 데 목적이 있음
  - **클라이언트에서 실행되는 JS 코드를 포함시키거나 렌더링하는 역할까지 해주지 않음**
  - 필요한 JS 코드는 생성된 HTML과는 별도로 제공해 브라우저에 제공돼야 함
- 초기 렌더링에서 뛰어난 성능을 보여주며, 메타 정보도 미리 준비한 채 제공할 수 있음

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" width="40px" /> **리액트의 SSR의 목적은 단순히 ‘최초 HTML 페이지를 빠르게 그려주는 것’이다.**

---

- 완성된 HTML을 빠르게 볼 수는 있지만 useEffect나 이벤트 핸들러가 없어 사용자와 인터랙션할 준비가 되기 위해서는 별도의 JS 코드를 모두 다운로드, 파싱, 실행하는 과정을 거쳐야 함
- div#root에 data-reactroot 속성이 존재하는데, 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역할을 하여 hydrate 함수에서 루트를 식별하는 기준이 됨
</aside>

### renderToStaticMarkup

- renderToString과 매우 유사하지만, data-reactroot와 같은 **리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다**는 점이 차이점
- 이 함수를 실행한 결과로 렌더링하면 클라이언트에서는 리액트에서 제공하는 useEffect와 같은 API를 절대 실행할 수 없음 → hydrate를 수행하지 않는 순수 HTML만 반환
- **리액트의 이벤트 리스너가 필요하지 않은 완전 순수 HTML을 만들 때 사용**
  - 예를 들어 상품 약관 정보, 블로그 글과 같은 브라우저 액션이 없는 정적인 내용

### renderToNodeStream

renderToString과 결과물이 동일하지만, **두 가지 큰 차이점**이 있다.

- rednerToNodeStream은 **브라우저에서 사용할 수 없고, Node.js 환경에서만 사용**할 수 있음
- 결과물의 타입이 string 문자열이 아닌 Node.js의 ReadableStream
  - ReadableStream은 브라우저에서 사용할 수 있지만 만들수는 없도록 구현되어있음
- 생성할 HTML을 작은 단위로 쪼개 작성하여 서버의 부담을 덜 수 있음
  - 대부분의 널리 알려진 리액트 SSR 프레임워크는 모두 renderToNodeStream을 채택

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" width="40px" /> **스트림(Stream)이란?**

---

- 스트림은 큰 데이터를 다룰 때 데이터를 청크(chunk, 작은 단위)로 분할해 조금씩 가져오는 방식을 의미함
- 생성한 HTML 결과물의 크기가 매우 클 경우, 문자열을 한 번에 메모리에 올려두고 응답을 수행해야 해서 서버에 큰 부담이 될 수 있음
- 스트림을 활용하면 이러한 큰 크기의 데이터를 분리하여 처리할 수 있다는 장점이 있음
</aside>

### renderToStaticNodeStream

- renderToNodeStream의 renderToStaticMarkup이라고 볼 수 있음
- renderToNodeStream과 제공하는 결과물은 동일하지만 자바스크립트에 필요한 리액트 속성이 제공되지 않아 hydrate를 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드

### hydrate

- HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할
- 단순히 서버에서 렌더링한 HTML 결과물로 사용자에게 무언가를 보여줄 수는 있으나, 사용자가 페이지와 인터랙션하는 것이 불가능하기에 hydrate를 통해 이벤트 핸들러를 붙임
- render 함수와 비교하기
  ```tsx
  const rootEl = document.getElementById('root');
  ReactDOM.render(<App />, rootEl);
  ```
  - render는 HTML 요소에 컴포넌트를 렌더링하면서 이벤트 핸들러를 붙이는 작업을 한번에 수행
  ```tsx
  // container Id를 가리키는 element는 서버에서 렌더링된 HTML의 특정 위치를 의미
  const el = document.getElementById(containerId);
  ReactDOM.hydrate(<App />, el); // 해당 element를 기준으로 리액트 이벤트 핸들러를 붙임
  ```
  - 기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고, 이벤트를 붙이는 작업만 실행
- **두 번째 인수에는 이미 렌더링된 정적인 HTML이 반드시 존재해야 함**

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" width="40px" /> **서버 사이드 렌더링 예제 프로젝트 정리**

리액트에서 성능이 보장된 SSR을 수행하기 위해선 매우 복잡한 코드가 필요하며, 개발자 개인이 이를 작성하는 것은 매우 비효율적이다. 리액트 18에서는 suspense나 concurrent, 그리고 서버 사이드 렌더링과는 약간 다른 서버 컴포넌트 등의 새로운 개념이 추가되면서 서버에서 렌더링하는 것이 더욱 복잡해졌다. 서버 사이드 렌더링 자체만으로 개발자에게는 큰 도전이다.

</aside>

## Next.js 톺아보기

---

리액트 팀에서조차 아무것도 없는 상태에서 리액트만으로 서버 사이드 렌더링 웹을 구현하는 것을 권장하지 않는다. 서버 사이드 렌더링 프레임워크 중 가장 인기있는 Next.js를 살펴보자.

### Next.js

리액트에서 사장한 프로젝트 react-page의 구현 방향성에 Vercel이 영감을 받아 개발된 리액트 서버 사이드 렌더링 프레임워크

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" width="40px" /> **2023년 2월 (Next.js 13)의 page 라우터 기준으로 작성**

</aside>

### 시작하기

`create-next-app`으로 Next.js 프로젝트 보일러 플레이트를 생성할 수 있음

- `package.json`을 살펴보면, next 패키지와 eslint-config-next 패키지가 생김
- `next.config.js` 파일에는 프로젝트의 환경 설정을 담당함

**pages/\_app.tsx**

`_app.tsx`와 내부의 default export로 내보낸 함수가 앱 전체 페이지의 시작점

최초 서버 사이드 렌더링 이후에는 클라이언트에서 `_app.tsx`의 렌더링이 실행됨

웹 앱에서 공통으로 설정해야 하는 것들을 여기에서 실행할 수 있음

- 에러 바운더리를 사용해 앱 전역에서 발생하는 에러 처리
- reset.css와 같은 전역 CSS 선언
- 모든 페이지에 공통으로 사용 또는 제공해야 하는 데이터 제공 등

**pages/\_document.tsx**

파일은 서버 사이드에서 렌더링 되는 HTML 문서의 구조를 커스터마이징할 수 있는 파일로, 이 파일을 통해 전체 HTML 문서의 **`<html>`**, **`<head>`**, **`<body>`** 등을 수정할 수 있다. 주로 다음과 같은 기능을 담당한다.

```tsx
// pages/_document.tsx
import Document, { Html, Head, Main, NextScript } from 'next/document';

class MyDocument extends Document {
  static async getInitialProps(ctx) {
    const initialProps = await Document.getInitialProps(ctx);
    return { ...initialProps };
  }

  render() {
    return (
      <Html>
        <Head>
          <meta name="description" content="My Next.js App" />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;
```

`_app.tsx`가 앱 페이지 전체를 초기화하는 곳이라면, `_document.tsx`는 애플리케이션의 HTML을 초기화하는 곳으로 몇 가지 차이점이 있음

- <html>이나 <body>에 DOM 속성을 추가하고 싶다면 `_document.tsx`를 사용
- `_app.tsx`는 렌더링이나 라우팅에 따라 서버나 클라이언트에서 실행될 수 있지만 `_document`는 무조건 서버에서 실행 (이벤트 핸들러 추가 불가 → 클라이언트의 hydrate의 몫)
- 웹 앱에 공통적인 제목이 필요하면 `_app.tsx`에 next/head의 <head>를 사용하고, 페이지별 제목이 필요하다면 페이지 파일 내부에서
- 서버에서 사용 가능한 데이터 불러오기 함수(getServerSideProps,getStaticProps)는 여기서 사용할 수 없음
- CSS-in-JS의 스타일을 서버에서 모아 HTML로 제공하는 것은 `_document.tsx`에서만 가능

`_app.tsx`는 Next.js를 초기화하는 파일, next.js 설정과 관련된 코드를 모으는 곳, 경우에 따라서버와 클라이언트 모두에서 렌더링될 수 있음

`_document.tsx는` Next.js로 만드는 웹앱의 뼈대가되는 HTML 설정과 관련된 코드를 추가하는 곳, 반드시 서버에서만 렌더링될 수 있음

**pages/\_error.tsx**

- 기본 생성 파일은 아니며, 클라이언트 발생 에러 또는 서버에서 발생하는 500 에러를 처리하는 목적을 가짐
- 개발 모드에서는 방문할 수 없고 에러가 발생하면 Next.js가 제공하는 개발자 에러 팝업이 나타나며, 확인을 위해서는 프로덕션으로 빌드해서 확인해야 함

**pages/404.tsx**

- 404 페이지를 정의할 수 있는 파일
- 제공하지 않으면 디폴트 404 페이지를 볼 수 있음

**pages/500.tsx**

- 서버 발생 에러 핸들링 페이지
- \_error와 500 모두 제공하지 않으면 디폴트 페이지를 볼 수 있음
- \_error.tsx보다 500.tsx의 우선순위가 높아 먼저 실행됨

**pages/index.tsx**

여기부터 개발자가 자유롭게 명칭을 지정할 수 있는 페이지로, /pages 디렉터리를 기초로 구성되어 각 페이지에 있는 default export로 내보낸 함수가 해당 페이지의 루트 컴포넌트이다.

- `/pages/index.tsx` : 웹사이트의 루트
- `/pages/hello.tsx` : /pages가 생략되고, 파일명이 주소가 됨 (localhost:3000/hello로 접근)
- `/pages/hello/world.tsx`
  디렉터리의 깊이만큼 주소를 설정할 수 있음 (localhost:3000/hello/world로 접근)
  hello/index.tsx와 hello.tsx 모두 같은 주소를 바라본다는 점을 주의
- `/pages/hello/[greeting].tsx`
  `[]`의 의미는 어떠한 문자도 올 수 있으며, 동적 라우팅할 수 있다는 의미
  미리 정의한 주소가 있다면 그 주소가 우선됨
- `/pages/hi/[…props].tsx`
  실제로 JS 전개 연산자와 동일하게 동작하며, /hi를 제외한 /hi 하위의 모든 주소가 올 수 있음
  […props] 값은 props라는 변수에 배열로 오게 됨

`[]`안의 내용은 내용은 변수로 처리된다는 점을 주의하자.

주소에 숫자를 입력했더라도 숫자로 타입 변환이 되지 않음을 주의하자.

주소에 하나만 들어갔다 하더라도, string 1이 아닌 string[] [1]이 들어간다는 것을 주의하자.

[…props]와 같이 전개 연산자로 선언한 모든 주소는 배열로 들어간다.

**서버 라우팅과 클라이언트 라우팅**

Next.js의 SSR의 빠르게 최초 페이지를 제공과 SPA의 자연스러운 라우팅이라는 두 가지 장점을 살리기 위해서는 내부 페이지 이동에 다음의 규칙을 지키자.

- `<a>` 대신 next/link의 `<Link>`를 사용한다.
- **window.location.push** 대신 **router.push**를 사용한다.

**페이지에서 getServerSideProps를 제거하면 어떻게 될까?**

getServerSideProps 메서드가 없으면 서버에서 실행하지 않아도 되는 페이지로 처리하고 typeof window의 처리를 모두 object로 바꾼 다음, 빌드 시점에서 미리 트리 쉐이킹을 해버린다. Next.js는 SSR 프레임워크지만 모든 작업이 서버에서 일어나는 것은 아니다.

**/pages/api/hello.tsx**

api 디렉터리는 하위에 서버의 API를 정의하는 폴더로, 라우팅 구조는 위에서 언급한 것과 동일하되, /api/ 라는 접두사가 붙는다는 점만 다르다.

- 서버에서 내려주는 데이터를 조합해 BFF 형태로 활용할 수 있음
- 완전한 풀스택 앱을 구축하고 싶을 때, 혹은 CORS 문제를 우회하기 위해 사용될 수 있음

### Data Fetching

SSR 지원을 위한 몇 가지 데이터 불러오기 전략을 Next.js에서는 Data Fetching이라 한다. page/ 하위에 있는 라우팅이 되는 파일에서만 사용할 수 있으며, **예약어로 지정되어 반드시 정해진 함수명으로 export를 사용**해 외부로 보내야 한다.

- 미리 필요한 페이지를 만들어서 제공할 수 있음
- 서버에서 데이터를 조회해서 미리 페이지를 만들어 제공할 수 있음

**getStaticPaths와 getStaticProps**

- 빌드 시 데이터 페칭 및 동적 경로의 정적 페이지 생성을 위한 경로 목록 제공 메서드
- getStaticProps는 정적 생성용 데이터를 가져와 페이지를 미리 생성하며, 빌드 시 한 번 실행되고 정적 페이지 생성하는 데 필요한 데이터를 제공
- getStaticPaths는 동적 라우팅을 사용하여 정적 페이지를 사전 생성할 경로 목록을 정의하며 getStaticProps와 함께 사용
- 제공할 페이지 수에 따라 적다면 페이지를 빌드 시점에 미리 준비하거나 많다면 fallback을 사용해 사용자의 요청이 있을 때만 빌드하는 등의 최적화를 추가할 수 있음

**getServerSideProps**

- 요청마다 서버에서 데이터를 가져와 페이지를 렌더링하는 역할, **무조건 서버에서만 실행됨**
- 서버에서 실행되는 메서드로, 해당 함수가 있으면 무조건 페이지 진입 전에 이 함수를 실행
- 응답 값에 따라 루트 컴포넌트에 props를 반환할 수도, 혹은 다른 페이지로 리다이렉트시킬 수도 있음
- 이 메서드가 있으면 Next는 페이지를 꼭 서버에서 실행해야 하는 페이지로 분류하여 서버용 자바스크립트 파일을 별도로 생성

**getInitialProps**

- 이전 버전(Next.js 9.3까지)에 존재했던 유일한 데이터 페칭 메서드로, 현재는 대부분의 경우 getStaticProps와 getServerSideProps 사용을 권장
- Next.js 페이지 또는 커스텀 App 컴포넌트에서 초기 데이터를 가져오는 데 사용
- 서버 사이드 렌더링과 클라이언트 사이드 네비게이션 모두에서 작동
- `_app.tsx`나 `_error.tsx`와 같이 Next 특성상 사용이 제한돼 있는 페이지에서만 사용

| 메서드             | 실행 시점      | 설명                                                 | 사용 사례                                |
| ------------------ | -------------- | ---------------------------------------------------- | ---------------------------------------- |
| getStaticProps     | 빌드 시        | 정적 생성용 데이터를 가져와 페이지를 미리 생성       | 블로그 포스트, 제품 목록                 |
| getStaticPaths     | 빌드 시        | 동적 경로의 정적 페이지 생성을 위해 경로 목록 제공   | 각 포스트 페이지, 제품 상세 페이지       |
| getServerSideProps | 요청 시        | 각 요청마다 서버에서 데이터를 가져와 페이지를 렌더링 | 사용자 인증 페이지, 실시간 데이터 페이지 |
| getInitialProps    | 페이지 로드 시 | 초기 데이터를 가져오는 데 사용                       | Next.js 9.3 이전 프로젝트, 공통 데이터   |

### 스타일 적용

**전역 스타일 적용**

- `_app.tsx`에 필요한 스타일을 import 하면 된다.
- 글로벌 스타일은 충돌 위험성이 있으므로 반드시 \_`app.tsx`에서만 사용

**컴포넌트 레벨 CSS**

- `[name].module.css`와 같은 명명 규칙만 준수하면 됨
- 고유한 클래스명을 제공하여 다른 컴포넌트와 충돌을 방지
- 어떤 파일에서도 컴포넌트 레벨 CSS를 추가할 수 있음

**SCSS와 SASS**

- CSS와 동일한 방식으로 사용하되, SCSS의 변수를 컴포넌트에 사용하려면 :export 문법 활용
  ```tsx
  $primary: blue;
  :export { primary: $primary; }
  //-------------------------------------------
  import styles from './Button.module.scss';
  styles.primary
  ```

**CSS-in-JS**

- **styled-components** 스타일을 Next.js에 추가하기 위해서는 `**_document.tsx`에 아래와 같이 추가\*\*

  ```tsx
  // pages/_document.js
  import Document, { Html, Head, Main, NextScript } from 'next/document';
  import { ServerStyleSheet } from 'styled-components';

  const MyDocument = ({ styles }) => {
    return (
      <Html>
        <Head>{styles}</Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  };

  MyDocument.getInitialProps = async (
    ctx: DocumentContext
  ): Promise<DocumentInitialProps> => {
    const sheet = new ServerStyleSheet();
    const originalRenderPage = ctx.renderPage;

    console.log(sheet);

    try {
      ctx.renderPage = () =>
        originalRenderPage({
          enhanceApp: (App) => (props) =>
            sheet.collectStyles(<App {...props} />),
        });

      const initialProps = await Document.getInitialProps(ctx);
      return {
        ...initialProps,
        styles: (
          <>
            {initialProps.styles}
            {sheet.getStyleElement()}
          </>
        ),
      };
    } finally {
      sheet.seal();
    }
  };

  export default MyDocument;
  ```

  리액트 트리 내부에서 사용하고 있는 styled-components의 스타일을 모두 모은 다음, 이 각각의 스타일에 유니크한 클래스명을 부여해 스타일이 충돌하지 않게 클래스명과 스타일을 정리하여 이를 \_document.tsx가 서버에서 렌더링할 때 React.Context 형태로 제공하는 것이다.
  이 과정을 거치지 않으면 FOUC(flash of unstyled content)를 노출하게 된다.
  바벨이 아닌 SWC를 사용한다면 next.config.js에 compiler.styledComponents를 추가하면 된다.

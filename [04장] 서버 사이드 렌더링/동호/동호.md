# 서버 사이드 렌더링

---

### 서버 사이드 렌더링

- [4.1. 서버 사이드 렌더링이란?](https://www.notion.so/200f0f7ac8fb4efca7594c297cd9fd16?pvs=21)
- 4.2. 서버 사이드 렌더링을 위한 리액트 API 살펴보기
- 4.3. Next.js 톺아보기

## 서버 사이드 렌더링이란?

---

> 리액트 개발자라면, 특히 다수의 사용자에게 좋은 사용자 경험을 제공할 수 있는 웹 애플리케이션을 만들고 싶은 개발자라면 두 가지 방법(CSR, SSR)을 모두 숙지할 필요가 있다.

왜 서버 사이드 렌더링이 각광받고 있는지 웹 세계의 현주소와 맥락을 따라가보자.

### **싱글 페이지 애플리케이션 세상**

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" width="40px" /> **싱글 페이지 애플리케이션 (SPA)**

---

렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식으로, 최초에 첫 페이지에서 데이터를 모두 불러온 이후에는 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 history.pushState와 history.replaceState로 이루어진다.

- 부드러운 사용자 경험과 빠른 반응 속도, 일관성 유지 등의 장점
- 많은 리소스를 한 번에 로드해야 하기에 초기 로딩이 길어지고, 클라이언트 측에서 상태를 관리하므로 코드가 복잡해지며, 자바스크립트에 의존하기에 브라우저 호환성 문제가 발생하는 단점
</aside>

**전통적인 방식의 애플리케이션과 SPA 작동 비교**

- 과거 서버 사이드에서 작동하던 전통적인 방식의 앱은 페이지 전환이 발생할 때마다 새롭게 페이지를 요청하고, HTML 페이지를 다운로드해 파싱해야 함
- 이 과정에서 페이지가 전환될 때 흰 화면이 잠시 노출되는 등의 부자연스러운 모습이 발생
- SPA는 최초 로딩 시간 이후에는 페이지 전환에 추가 리소스를 받을 필요가 없어짐
- 또한 경우에 따라 페이지 전체가 아니라 페이지 전환에 필요한 일부 영역만 렌더링하면 되므로 더 매끄러운 UI를 보여줄 수 있음

**싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장**

- 과거 PHP나 JSP 기반 웹이 유행이었을 때는 대부분 SSR로 동작, 자바스크립트는 어디까지나 사용자에게 추가적인 경험을 주기 위한 보조적인 수단으로 사용
  ⬇️
- 자바스크립트의 발전과 모듈화(CommonJS와 AMD), 사용자 기기의 성능 향상과 인터넷 속도의 발전으로 자바스크립트의 역할이 다양화
- 2010년 경 Backbone.js와 AngularJS, Knockout.js 등이 등장
- 자바스크립트에서 MVx 프레임워크를 구현, 어느 정도 서버에서만 할 수 있었던 복잡한 작업을 하기 시작 → React, Vue, Angular의 시대 도래
- SPA는 자바스크립트만 잘 작성하면 되어서 개발자에게 더 편리했으므로 폭발적으로 성장

<aside>
<img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" alt="https://prod-files-secure.s3.us-west-2.amazonaws.com/a4790dc2-7f52-4617-8fd1-fef1df1a6dec/959e0097-e64b-4ffb-8ccb-0b48d1fc10e8/Rectangle.png" width="40px" /> **JAM 스택 (Javascript, API, Markup)**

---

- 기존 웹 개발의 주축이었던 LAMP 스택(Linux, Apache, MySQL, PHP/Python)
- 위 스택의 서버 의존적인 문제는 웹앱의 확장성에 걸림돌이 되었고, 클라우드 개념이 부족했던 당시에는 서버 확장에도 어려움을 겪었음
- 앞서 언급한 프레임워크의 등장으로 대부분의 작업을 자바스크립트에서 수행할 수 있었기 때문에 서버 확장성에서 자유로워 졌음
- JAM 스택의 인기와 Node.js의 고도화에 힘입어 MEAN(MongoDB, Express.js, AngularJS, Node.js)이나 MERN(MongoDB, Express.js, React, Node.js) 스택처럼 API 서버 자체도 자바스크립트로 구현하는 구조가 인기를 끔
</aside>

**새로운 패러다임의 웹서비스를 향한 요구**

- 기기의 성능과 인터넷 속도는 날이 갈수록 빨라졌지만, 이와 맞추어 자바스크립트 리소스의 크기와 수 모두 증가하기 시작
- 하지만 웹페이지의 로딩 속도는 5년 전이나 지금이나 크게 차이가 없거나 오히려 더 느림

### 서버 사이드 렌더링이란?

웹페이지가 점점 느려지는 상황에 대해 SPA의 태생적 한계에서 문제 의식을 갖고, 기존 방식의 웹 개발(SSR)이 다시금 떠오르고 있는 상황이다.

**서버 사이드 렌더링의 장점**

- 비교적 최초 페이지 진입이 빠름
  일반적으로 서버에서 HTTP 요청을 수행하는 것이 더 빠르고, HTML을 그리는 작업도 서버에서 해당 HTML을 문자열로 미리 그려서 내려주는 것이 클라이언트에서 기존 HTML에 삽입하는 것보다 더 빠르다. 화면 렌더링이 HTTP 요청에 의존적이거나 렌더링해야 할 HTML의 크기가 커진다면 상대적으로 SSR이 더 빠를 수 있다.
- 비교적 유저 디바이스 성능에서 자유로움

  사용자 디바이스에서 실행되는 자바스크립트 리소스의 크기가 줄어드므로 비교적 디바이스 성능에서 자유롭다고 할 수 있다.

- 누적 레이아웃 이동(CLS)이 적음

  뒤늦게 HTML에 정보를 추가하거나 삭제하지 않으므로 화면이 덜컥거려 보이는 현상이 비교적 적다.

- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉬움

  검색 엔진이 사이트에서 필요한 정보를 가져가는 과정은 검색 엔진 로봇이 페이지에 진입하여 HTML을 다운로드하고 내부의 오픈 그래프나 메타 태그 정보를 기반으로 검색/공유 정보를 가져와 검색 엔진에 저장한다. 자바스크립트 코드는 실행하지 않기 때문에 메타 정보를 제공하도록 조치하지 않으면 페이지 노출에 불이익이 있다.

- 보안에 좀 더 안전함
  JAM 스택 프로젝트의 문제점은 앱의 모든 활동이 브라우저에 노출된다는 점이다. API 호출과 인증 같이 사용자에게 노출되서는 안되는 민감한 작업도 포함되므로 이를 신경써야만 했는데, SSR은 민감한 작업을 서버에서 수행하고 결과만 제공하여 보안 위협을 피할 수 있다.

**서버 사이드 렌더링의 단점**

- 소스 코드 작성 시 항상 서버를 고려해야 함
  가장 큰 문제는 브라우저 전역 객체인 window나 sessionStorage같은 객체를 사용할 수 없기 때문에 서버에서 실행될 수 있는 코드에서는 window 접근을 최소화해야 한다. 사용이 불가피한 경우 해당 코드가 서버 사이드에서 실행되지 않도록 처리해야 한다. 또한 외부 의존성 라이브러리도 서버에 대한 고려가 되어 있지 않으면 다른 대안을 찾거나 클라이언트에서 실행되도록 처리해야 하지만, 클라이언트에서 실행되는 코드가 많아질수록 SSR의 장점을 잃는다.
- 적절한 서버가 구축되어 있어야 함
  서버를 구축하는 것은 쉬운 일이 아니며, 물리적 가용량, 에러 대처 등의 복구 전략도 필요하다. 요청 분산, 프로세스 다운될 때를 대비도 필요하다. 여러 라이브러리 및 도구의 도움을 얻더라도 절대 쉽지 않은 일이다.
- 서비스 지연에 따른 문제가 발생할 수 있음
  SPA에서는 느린 작업이 있더라도 화면에 로딩 중임을 알리는 UI를 안내하면 사용자가 인내할 여지가 있으나, SSR에서 만약 최초 렌더링에 지연이 발생하면 사용자에게 어떤 정보도 제공할 수 없다는 문제가 발생한다. 다양한 요청에 얽혀 병목 현상이 심해지면 SSR이 더 안 좋은 사용자 경험을 제공할 수도 있다.

### SPA와 SSR을 모두 알아야 하는 이유

서버 사이드 렌더링은 만능이 아니며, 웹 페이지의 설계와 목적, 우선순위에 따라 SPA가 더 효율적일 가능성이 있다. SPA와 SSR 애플리케이션을 성능에 따라 비교해보자.

**가장 뛰어난 SPA > 가장 뛰어난 MPA**

- 최초 페이지 진입 시 보여줘야 할 정보만 최적화하여 요청해서 렌더링
- 이미지 같이 중요성이 떨어지는 리소스는 lazy loading으로 처리
- 코드 분할을 칼같이 해서 불필요한 js 리소스의 다운로드 및 실행을 방지

SSR 방식의 MPA가 엄청난 최적화를 하더라도, SPA 방식의 브라우저 API와 JS를 활용한 라우팅 기반의 매끄러운 라우팅보다 뛰어나진 못할 것이다.

**평균적인 SPA < 평균적인 MPA**

- 일반적 SPA에서 렌더링과 라우팅에 최적화가 되어있지 않다면 사용자 기기에 따라 성능이 들쑥날쑥할 것
- 매번 서버에 렌더링 요청을 하고, 안정적인 리소스 기반으로 매 요청을 비슷한 성능으로 렌더링하는 경우가 더 뛰어남
- 페이지 전환 시 필요한 리소스와 공통으로 사용하는 리소스를 분류하고 이에 따른 다운로드나 렌더링 우선순위 전략을 잘 수립하여 SPA를 최적화하기는 매우 어려운 작업
- 따라서 평균적인 노력으로 동일한 서비스를 만들 경우 MPA가 우세할 것
- 또한 최근 MPA에서 발생하는 라우팅으로 인한 문제를 해결하기 위한 다양한 API가 브라우저에 추가되고 있는 추세
  - `페인트 홀딩(Paint Holding)` : 같은 출처(origin)에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신에 이전 페이지의 모습을 잠깐 보여주는 기법
  - `bfcache(back forward chache)` : 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
  - `Shared Element Transitions` : 페이지 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법

두 방식 모두 장단점이 있으며 어느 하나 완벽하다 할 수 없으므로 두 방법론을 모두 알아야 할 필요가 있다.

### **현대의 서버 사이드 렌더링**

**기존 LAMP 스택**

- 모든 페이지 빌드를 서버에서 렌더링해 초기 페이지 진입이 빠르지만, 이후 라우팅이 발생할 때도 마찬가지로 서버에 의존해야 하기 때문에 SPA 방식에 비해 라우팅이 느림

**요즘의 서버 사이드 렌더링**

- SPA와 SSR의 장점을 모두 취한 방식으로 동작한다.
- 최초 웹사이트 진입 시에는 SSR 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 SPA처럼 작동함
- Next.js, Remix 등의 서버 사이드 렌더링 프레임워크들은 이러한 방식으로 작동하여 더 나은 웹사이트 경험을 제공함
- 때문에 서버 사이드 렌더링, 클라이언트 사이드 렌더링을 모두 이해해야 두 가지 장점을 완벽하게 취하는 웹사이트를 구축할 수 있음

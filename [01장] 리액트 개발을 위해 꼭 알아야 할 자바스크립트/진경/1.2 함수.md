#### 🔗 1.2.1 함수란 무엇인가?

JS에서 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미한다.

```
// 컴포넌트를 만드는 함수
// Component라고 하는 함수를 선언하고 매개변수로 일반적으로 props라고 부르는 단일 객체를 받으며 return 문으로 JSX를 반환한다.

function Component(props) {
  return <div>{props.hello}</div>
}

// props 전달하기
// 단일 props 전달하기
<Component hello={props.hello} />

// 모든 props 전달하기
<Component {...props} />
```

#### 🔗 1.2.2 함수를 정의하는 4가지 방법

1. 함수 선언문

   ```
   // 함수 선언문은 표현식이 아닌 일반 문으로 분류된다. (표현식은 단일 값을 생성한다.)
   function add(a, b) {
     return a + b
   }

   // 아래의 예제는 sum 이라는 변수에 함수 sum을 할당하는, 표현식과 같은 작동을 보인다.
   // 이는 JS 엔진이 코드의 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하는 경우가 있기 때문이다.
   const sum = function sum(a, b) { // 함수 표현식
     return a + b
   }

   sum(10, 24) // 34
   ```

- 위와 같이 이름을 가진 형태의 함수 리터럴은 코드 문맥에 따라 선언문으로도, 표현식으로도 사용될 수 있다.

2. 함수 표현식
   > 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다. 함수 또한 일급 객체로, 함수는 다른 함수의 매개변수가 될 수 있고, 반환값이 될 수 있으며, 앞에서 본 것 처럼 할당도 가능하다.

- 함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적이다.

  ```
  const sum = function (a, b) {
    return a + b
  }

  sum(10, 20) // 30
  add(10, 24) // Uncaught referenceError: add is not defined
  ```

- ⭐️ **함수 표현식과 선언 식의 차이**
  **호이스팅 여부**이다. <br/>함수의 호이스팅이라 함은, 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징을 의미한다.

  ```
  hello() // hello

  function hello() {
    console.log('hello')
  }

  hello() // hello
  ```

  함수 표현식은 함수를 변수에 할당했다. 변수도 마찬가지로 호이스팅이 발생한다. 하지만 함수의 호이스팅과는 다르게, 호이스팅되는 시점에서 var의 경우 `undefined`로 초기화 된다는 차이가 있다.

  ```
  console.log(typeof hello === 'undefined') //true

  hello() // Uncought TypeError: hello is not a funcition

  var hello = function () {
    console.log('hello')
  }

  hello()
  ```

  함수와 다르게 변수는, 런타임 이전에 undefined로 초기화되고, 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다.
  <br/>

- ⭐️ 함수 표현식과 함수 선언식 둘 중 어떤 것을 선택해야 할까?
  - 함수 선언문 : 함수가 선언된 위치에 상관없이 함수 호이스팅의 특징을 살리면 어디서든 호출 할 수 있기 있기 때문에 어디서든 자유롭게 호출하고 싶을때 사용하면 좋다. 또한 명시적으로 함수를 구별하고 싶을 때도 함수 선언문을 사용하면 좋다.
  - 함수 표현식 : 하지만 함수가 선언되기 전에 함수가 호출되는 것이 이상하게 느껴질 수 있다. 그리고 실제 함수를 어디서 선언했는지는 해당 스코프를 끝까지 확인하지 않으면 개발자가 찾기 어렵기 때문에 이와 같이 생각한다면 함수 표현식을 선택하는 것도 방법이다.

3. Function 생성자(constructor)

   ```
   const add = new Function('a', 'b', 'return a + b')

   add(10, 24)
   ```

4. 화살표 함수

   ```
   const add = (a, b) => {
     return a + b
   }

   const add = (a, b) => a + b
   ```

   [생성자 함수 (= 생성자)](https://ko.javascript.info/constructor-new)

   <br/>

   - 생성자 함수로 화살표 함수를 사용하는 것은 불가능하다.

     ```
     const Car = (name) => {
       this.name = name
     }

     //Uncaught TypeError: Car is not a constructor
     const myCar = new Car('하이')
     ```

   - 화살표 함수에서는 arguments가 존재하지 않는다.
   - 함수 자체의 this 바인딩을 갖지 않는다. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다. (만약 함수가 일반 함수로서 호출되면, 그 내부의 this는 전역 객체를 가리키게 된다.)

#### 🔗 1.2.3 다양한 함수 살펴보기

- 즉시 실행 함수 (= IIFE)

  - 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다.
  - 단 한 번만 호출되고, 다시 호출 할 수 없는 함수이기 때문에 일반적으로 즉시 실행 함수에 이름을 붙이지 않는다.
  - 재사용되지 않는 함수이고, 단 한 번만 실행되고 끝난다면 IIFE 사용을 검토해 보자.

    ```
    (function (a, b) {
      return a + b
    })(10, 24) // 34

    ((a, b) => {
        return a + b
      },
    )(10, 24) // 34
    ```

- 고차 함수

  - JS의 함수는 일급 객체이기 때문에 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다. 이런 역할을 하는 함수를 고차 함수라고 한다.

  ```
  // Array.prototype.map => 함수를 매개변수로 받는 대표적인 고차 함수이다.
  const doubledArray = [1,2,3].map((item) => item * 2)

  doubledArray // [2, 4, 6]
  ```

#### 🔗 1.2.4 함수를 만들 때 주의해야 할 사항

1. 함수의 부수효과(side-effect)를 최대한 억제하라.

- 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 억제해야 한다.
- 이러한 부수 효과가 없는 함수를 순수 함수라 한다.
  - 동일한 인수를 받으면 동일한 결과를 반환한다.
  - <=> 부수 효과가 존재하는 함수를 비순수 함수라고 한다.

2. 가능한 한 함수를 작게 만들어라.

- `max-lines-per-function` ESLint 규칙 : 기본값이 50줄 이상 넘어가면 경고 메세지를 출력한다. (이 외에도 중첩이 얼마나 있고 콜백이 얼마나 많은지도 이 규칙에서 확인 가능하다.)

3. 누구나 이해 할 수 있는 이름을 붙여라.

- 간결하고 이해하기 쉽게 붙이는 것이 좋다.

# 리액트 개발을 위해 꼭 알아야 할 자바스크립트

---

이 장에서는 리액트 코드를 작성하고 작동 방식을 이해하기 위한 최소한의 자바스크립트에 대해서 다룬다.

---

@khakhiD 

### 리액트가 프론트엔드 시장을 점령할 수 있었던 이유

<aside>
1️⃣ **명시적 상태 변경**

- 리액트는 단방향 바인딩으로 명시적으로 상태 변화가 이루어지기 때문에 많은 개발자들에게 간단함과 유연함을 제공할 수 있다.
- 단방향 바인딩의 단점은 항상 변화를 감지하고 업데이트하는 코드를 매번 작성해야 해서 코드 규모가 증가하는 단점이 있다.
- `요약` **상태 흐름의 방향이 위에서 아래로만 흘러서 흐름을 이해하기 쉽지만, 코드 규모가 커지는 단점을 가진다.**
</aside>

<aside>
2️⃣ **JSX**

- JSX 문법은 기존 자바스크립트 문법에 약간의 HTML이 가미된 수준으로 몇 가지 특징만 이해한다면 손쉽게 사용할 수 있다.
</aside>

<aside>
3️⃣ 비교적 배우기 쉽고 간결함 (시작은 쉬우나 실력을 높이는데에는 비교적 난이도가 있음)

</aside>

<aside>
4️⃣ 리액트 커뮤니티의 규모

- 세계적으로 강력한 커뮤니티와 정보
- 국내 최근 전자정부 표준 프레임워크에 선정
</aside>

## 학습 목표

---

<aside>
💡 ***리액트 개발을 위해 꼭 알아야 할 자바스크립트의 언어적 특징 복습***

1. 자바스크립트의 동등 비교
2. 함수
3. 클래스
4. 클로저
5. 이벤트 루프와 비동기 통신의 이해
6. 리액트에서 자주 사용하는 자바스크립트 문법
7. 선택이 아닌 필수, 타입스크립트
</aside>

# 자바스크립트 동등 비교 (Equality Comparisons)

---

리액트 컴포넌트 렌더링이 일어나는 이유 중 하나가 바로 **props의 동등 비교에 따른 결과**다.

- 렌더링 최적화를 위해서는 리액트 컴포넌트 렌더링이 어떻게 작동하는지 알아야 한다.
- props의 동등 비교가 **객체의 얕은 비교 기반**으로 이루어진다.
- 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

### 원시 타입(primitive type)과 객체 타입(object/reference)의 차이점

가장 큰 차이점이 바로 `값을 저장하는 방식`이다.

**`원시 타입`은 불변 형태의 값으로 저장되며, 변수 할당 시점에 메모리 영역을 차지하고 저장된다.**

```jsx
let hello = 'hello world';
let hi = hello;

console.log(hello === hi)
// true
```

- `hello`의 `hello world`라는 값이 `hi`에 복사해 전달되었으므로 true가 나온다.

```jsx
let hello = 'hello world';
let hi = 'hello world';

console.log(hello === hi)
// true
```

- 값을 비교하기 때문에, 값을 전달하는 방식이 아닌 각각 선언하는 방식으로도 동일한 결과가 나온다.

**`객체 타입`은 프로퍼티를 삭제, 추가, 수정할 수 있으므로 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달한다.**

```jsx
var hello = {
	greet: 'hello, world',
}
var hi = {
	greet: 'hello, world',
}
	
console.log(hello === hi) 
// false

console.log(hello.greet === hi.greet)
// true
```

- 객체는 값을 저장하는 것이 아니라 참조를 저장한다.

```jsx
var hello = {
	greet: 'hello, world',
}
var hi = hello
	
console.log(hello === hi) // true
```

- `hi`는 `hello`와 동일한 주소를 가리키므로 `true`가 나온다

<aside>
👀 *객체 간 비교가 발생하면, 개발자가 이해하는 객체 내부의 값이 서로 같더라도 결과는 대부분 `false`라는 점을 인지해야 한다.*

</aside>

### 자바스크립트의 또 다른 비교 공식, Object.is

동등 비교를 위한 다른 방법으로 자바스크립트에서 제공하는 메서드인 `Object.is`와 `==`, `===`의 차이점을 이해하고 있어야 한다.

`**==**` 

- 동등 비교 연산자
- 타입 변환(형 변환, Type conversion)이 일어난 뒤 비교
    
    

`**===**` 

- 엄격한(strict) 동등 비교 연산자
- 타입 변환(Type conversion)이 일어나지 않으며,
타입이 일치해야만 동등한 것으로 간주
    
    

`**Object.is**` 

- 동등 비교 메서드 (ES6+ 이후)
- 동등 비교 `==`의 한계를 극복하기 위해 만들어 졌으나, 객체 간 비교에서는 `===`와 동일하게 동작함
- 사람(개발자)이 이해하는 방식으로 결과를 내주는 경우가 많음

### 동등 비교 예제

```jsx
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```

```jsx
var a = {}
var b = {}

a == b // false
a === b // false

var c = [];
var d = [];

c == d // false
c === d // false
```

```jsx
-0 === +0 // true
Object.is(-0, +0) // false

Number.NaN === NaN // false
Object.is(Number.NaN, NaN) // true

NaN === 0 / 0 // false
Object.is(NaN, 0 / 0) // true
```

```jsx
Object.is({}, {}) // false

const a = {
	hello: 'hi',
}
const b = a

Object.is(a, b) // true
a === b // true
```

<aside>
👀 ***리액트에서 동등 비교는 `Object.is` 메서드를 활용하여 구현되어 있다.***

</aside>

### 리액트에서의 동등 비교

**알아야 할 것**

- JSX Props는 객체로 취급한다.
- `Object.is`는 참조가 다른 객체 간의 비교가 불가능하다.
- 리액트 팀은 `shallowEqual`이라는 메서드를 구현하여 1depth 까지 객체 간 비교가 가능하게 만들었다.

```tsx
type Props = {
	hello: string
}

function HelloComponent(props: Props) {
	return <h1>{hello}</h1>
}
//...

function App() {
	return <HelloComponent hello="hi!" />
}
```

- 여기서 props는 객체다.
- 리액트는 props에서 꺼내온 값을 기준으로 렌더링한다.
- 일반적인 케이스에서 얕은 비교로 충분하다.
- 이러한 특성으로 props에 또 다른 객체를 넘겨주면 리액트 렌더링이 예상치 못하게 작동한다.
- 객체 안의 객체는 자바스크립트, 리액트에서 동등 비교가 어렵다는 것을 이해해야 한다.

<aside>
👀 ***리액트의 얕은 비교는 객체의 1 depth까지 비교할 수 있게 구현되어 있다는 점을 기억하자.
객체 안의 객체부터는 비교가 불가능하다.***

</aside>

<aside>
👀 ***자바스크립트 객체 비교의 불완전성은 다른 함수형 언어에서 볼 수 없는 자바스크립트만의 특징이다.
이러한 언어적 한계를 뛰어넘을 수 없으므로, 리액트는 얕은 비교만을 사용해 필요한 기능을 구현한다는 점을 꼭 숙지하자.***

</aside>

# 함수 (Function)

---

함수 파트에서는 기억해야 할 내용만 열거한다.

### 함수를 정의하는 4가지 방법

1. `함수 선언문` ― 사용됨
2. `함수 표현식`  ― 사용됨
3. `Function 생성자` ― 거의 사용되지 않음
4. `화살표 함수` ― 각광받음

### 함수 선언문과 함수 표현식의 차이

```tsx
function add(a, b) {
	return a + b
}
```

```tsx
const sum = function (a, b) {
	return a + b
}
```

함수 선언문은 표현식이 아닌 일반 문(statement)로 분류되는데, 표현식이란 무언가 값을 산출하는 구문을 의미한다. 함수 선언으로는 어떠한 값도 표현되지 않았으므로 표현식이 아닌 문으로 분류한다.

두 정의법의 가장 큰 차이점은 ***호이스팅(hoisting)*** 여부다.

```tsx
hello() // hello

function hello() {
	console.log('hello')
}

hello() // hello
```

- 함수 선언문은 호이스팅된다.

```tsx
console.log(typeof hello === 'undefined') // true
hello() // Uncaught TypeError: hello is not a function

var hello = function () {
	console.log('hello')
}

hello()
```

- 함수 표현식에서 함수를 할당한 변수는 호이스팅된다.
- 하지만 호이스팅 되는 시점에서 `var`의 경우 `undefined`로 초기화한다.

### 화살표 함수 (Arrow Function)

ES6에서 추가된 함수 생성 방식으로 타이핑할 글자 수가 줄어들고, 앞의 함수 생성 방식과 몇 가지 큰 차이점이 존재한다. 바로 this 바인딩의 문제다.

**자바스크립트의 this 바인딩 요약**

---

자바스크립트의 this는 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다.

- 전역 스코프에서 사용되면 `this`는 전역 객체를 가리킨다.
브라우저에서는 window 객체이고, 서버(노드)에서는 global 객체다.
- 함수에서 사용될 때에도 `this`는 전역 객체를 가리킨다.
- 객체에 속한 메서드에서 사용될 때 `this`는 메서드가 속한 객체를 가리킨다.
- 객체에 속한 메서드의 내부 함수에서 사용될 때 `this`는 전역 객체를 가리킨다.
- 생성자 함에서 사용될 때 `this`는 생성자로 인해 생성된 새로운 객체를 가리킨다.

---

<aside>
👀 ***내부 함수의 `this`가 지정되지 않고 전역 객체를 바인딩하는 문제는 자바스크립트 설계 상의 오류다. 원래 `this` 키워드는 다른 언어에서 ‘객체 자신에 대한 참조 값’을 의미한다. 따라서 자바스크립트에서는 내부 함수의 `this`가 전역 객체를 참조하는 것을 회피해야 한다.***

</aside>

[PoiemaWeb](https://poiemaweb.com/js-this)

자바스크립트의 this에 대한 내용

**화살표 함수와 다른 함수 정의법의 차이**

---

1. **생성자 함수로 화살표 함수를 사용하는 것은 불가능하다. ⇒ constructor 사용 불가**
2. **화살표 함수는 arguments를 가질 수 없다.**
3. **화살표 함수의 this는 함수 자체의 바인딩을 갖지 않는다. ⇒ this를 가지지 않는다!**
화살표 함수를 선언하면 this에 바인딩할 객체가 일반 함수와는 달리 정적으로 결정된다. 내부에서 this를 참조하면 언제나 상위 스코프의 this를 따르게 된다. 이를 Lexical this라고 한다.

---

이 문제로 인해 화살표 함수를 메서드로 정의하거나, 프로토타입에 할당하거나, 생성자 함수로 사용하거나, addEventListener 함수의 콜백 함수로는 화살표 함수를 사용해서는 안된다.

<aside>
👀 ***화살표 함수는 별도의 작업을 추가로 하지 않고 `this`를 접근할 수 있다.***

</aside>

<aside>
👀 ***`this`를 사용할 수밖에 없는 클래스형 컴포넌트 내부에서 화살표 함수를 사용할 때는 각별한 주의가 필요하다.***

</aside>

### 리액트에서 자주 사용되는 함수의 형태

**즉시 실행 함수 (IIFE)**

- 한 번 선언하고 호출된 후 더 이상 재호출이 불가하므로, 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다는 장점이 있다.
- 함수가 어디서든 다시 호출되지 않는다는 점을 알 수 있어 리팩터링에 도움이 된다.
    
    ```tsx
    (function (a, b) {
    	return a + b
    })(10, 24); // 34
    
    ((a, b) => {
    	return a + b
    	},
    )(10, 24) // 34
    ```
    

**고차 함수 (Higher Order Function)**

- 자바스크립트의 함수가 일급 객체라는 특징을 활용하여 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다. 이 역할을 하는 함수가 고차 함수다.
    
    ```tsx
    // 함수를 매개변수로 받는 대표적인 고차 함수, Array.prototype.map
    const doubledArray = [1, 2, 3].map((item) =-> item * 2)
    
    doubledArray // [2,4,6]
    ```
    
    ```tsx
    // 함수를 반환하는 고차 함수의 예
    const add = function (a) {
    	// a가 존재하는 클로저를 생성
    	return function (b) {
    		// b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
    		return a + b
    	}
    }
    
    add(1)(3) // 4
    ```
    
- 이 특징으로 리액트에서 함수형 컴포넌트를 인수로 받아 새로운 함수형 컴포넌트를 반환하는 고차 함수를 만들 수 있다. 이를 고차 컴포넌트라고 부른다.
- 고차 함수형 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있기 때문에 효율적인 리팩터링이 가능하다.

### 함수를 만들 때 주의해야 할 사항

좋은 함수는 무엇이고 함수를 만들 때 무엇을 조심해야 하는가?

- **함수의 부수 효과(side-effect)를 최대한 억제하라**
    - 사이드 이펙트는 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다.
    - 부수 효과가 없는 함수를 순수 함수라고 한다. 이는 언제 실행되어도 항상 결과가 동일하다.
    - 웹 앱에서 부수 효과는 피할 수 없는 요소다.
        - 컴포넌트 내부에서 API를 호출한다면 외부 영향(HTTP request)을 끼쳤으므로 부수 효과다. console.log 또한 외부에 영향을 미친다. 하지만 최대한 억제할 수 있는 방향으로 함수를 설계해야 한다.
    - 리액트의 관점에서 useEffect의 작동을 최소화하는 것이 그 일환이다.
- **가능한 한 함수를 작게 만들어라**
    - 하나의 함수가 하는 일이 많아질 경우 문제를 일으킬 수 있는 여지가 커진다.
    - 하나의 함수는 하나의 일을 잘 하면 함수의 재사용성을 높일 수 있다.
- **누구나 이해할 수 있는 이름을 붙여라**
    - Terser를 사용하면 한글로 함수 네이밍이 가능하다. (개발 단의 코드 크기나 번들링 속도에서 부담이 될 가능성은 있다.)
    - 리액트의 useEffect, useCallback 등의 훅에 넘겨주는 콜백 함수에도 네이밍을 붙여주면 도움이 된다.

# 클래스 (Class)

---

### 왜 클래스를 알아야 되는가?

- 16.8 버전 이전의 리액트에서는 모든 컴포넌트가 클래스로 작성되어 있었다.
- 리액트가 함수형으로 패러다임을 바꾼 지 이해할 수 있다.
- 자바스크립트의 프로토타입 기반으로 작동하는 클래스를 이해하면 자연스럽게 프로토타입에 대해서도 이해할 수 있다.

# 클로저 (Closure)

---
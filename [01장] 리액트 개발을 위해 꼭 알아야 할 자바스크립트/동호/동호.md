---
이 장에서는 리액트 코드를 작성하고 작동 방식을 이해하기 위한 최소한의 자바스크립트에 대해서 다룬다.
---

@khakhiD

### 리액트가 프론트엔드 시장을 점령할 수 있었던 이유

<aside>
1️⃣ **명시적 상태 변경**

- 리액트는 단방향 바인딩으로 명시적으로 상태 변화가 이루어지기 때문에 많은 개발자들에게 간단함과 유연함을 제공할 수 있다.
- 단방향 바인딩의 단점은 항상 변화를 감지하고 업데이트하는 코드를 매번 작성해야 해서 코드 규모가 증가하는 단점이 있다.
- `요약` **상태 흐름의 방향이 위에서 아래로만 흘러서 흐름을 이해하기 쉽지만, 코드 규모가 커지는 단점을 가진다.**
</aside>

<aside>
2️⃣ **JSX**

- JSX 문법은 기존 자바스크립트 문법에 약간의 HTML이 가미된 수준으로 몇 가지 특징만 이해한다면 손쉽게 사용할 수 있다.
</aside>

<aside>
3️⃣ 비교적 배우기 쉽고 간결함 (시작은 쉬우나 실력을 높이는데에는 비교적 난이도가 있음)

</aside>

<aside>
4️⃣ 리액트 커뮤니티의 규모

- 세계적으로 강력한 커뮤니티와 정보
- 국내 최근 전자정부 표준 프레임워크에 선정
</aside>

## 학습 목표

---

<aside>
💡 ***리액트 개발을 위해 꼭 알아야 할 자바스크립트의 언어적 특징 복습***

1. 자바스크립트의 동등 비교
2. 함수
3. 클래스
4. 클로저
5. 이벤트 루프와 비동기 통신의 이해
6. 리액트에서 자주 사용하는 자바스크립트 문법
7. 선택이 아닌 필수, 타입스크립트
</aside>

# 자바스크립트 동등 비교 (Equality Comparisons)

---

리액트 컴포넌트 렌더링이 일어나는 이유 중 하나가 바로 **props의 동등 비교에 따른 결과**다.

- 렌더링 최적화를 위해서는 리액트 컴포넌트 렌더링이 어떻게 작동하는지 알아야 한다.
- props의 동등 비교가 **객체의 얕은 비교 기반**으로 이루어진다.
- 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

### 원시 타입(primitive type)과 객체 타입(object/reference)의 차이점

가장 큰 차이점이 바로 `값을 저장하는 방식`이다.

**`원시 타입`은 불변 형태의 값으로 저장되며, 변수 할당 시점에 메모리 영역을 차지하고 저장된다.**

```jsx
let hello = 'hello world';
let hi = hello;

console.log(hello === hi);
// true
```

- `hello`의 `hello world`라는 값이 `hi`에 복사해 전달되었으므로 true가 나온다.

```jsx
let hello = 'hello world';
let hi = 'hello world';

console.log(hello === hi);
// true
```

- 값을 비교하기 때문에, 값을 전달하는 방식이 아닌 각각 선언하는 방식으로도 동일한 결과가 나온다.

**`객체 타입`은 프로퍼티를 삭제, 추가, 수정할 수 있으므로 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달한다.**

```jsx
var hello = {
  greet: 'hello, world',
};
var hi = {
  greet: 'hello, world',
};

console.log(hello === hi);
// false

console.log(hello.greet === hi.greet);
// true
```

- 객체는 값을 저장하는 것이 아니라 참조를 저장한다.

```jsx
var hello = {
  greet: 'hello, world',
};
var hi = hello;

console.log(hello === hi); // true
```

- `hi`는 `hello`와 동일한 주소를 가리키므로 `true`가 나온다

<aside>
👀 *객체 간 비교가 발생하면, 개발자가 이해하는 객체 내부의 값이 서로 같더라도 결과는 대부분 `false`라는 점을 인지해야 한다.*

</aside>

### 자바스크립트의 또 다른 비교 공식, Object.is

동등 비교를 위한 다른 방법으로 자바스크립트에서 제공하는 메서드인 `Object.is`와 `==`, `===`의 차이점을 이해하고 있어야 한다.

`**==**`

- 동등 비교 연산자
- 타입 변환(형 변환, Type conversion)이 일어난 뒤 비교

`**===**`

- 엄격한(strict) 동등 비교 연산자
- 타입 변환(Type conversion)이 일어나지 않으며,
  타입이 일치해야만 동등한 것으로 간주

`**Object.is**`

- 동등 비교 메서드 (ES6+ 이후)
- 동등 비교 `==`의 한계를 극복하기 위해 만들어 졌으나, 객체 간 비교에서는 `===`와 동일하게 동작함
- 사람(개발자)이 이해하는 방식으로 결과를 내주는 경우가 많음

### 동등 비교 예제

```jsx
'' == '0'; // false
0 == ''; // true
0 == '0'; // true

false == 'false'; // false
false == '0'; // true

false == undefined; // false
false == null; // false
null == undefined; // true

' \t\r\n ' == 0; // true
```

```jsx
var a = {};
var b = {};

a == b; // false
a === b; // false

var c = [];
var d = [];

c == d; // false
c === d; // false
```

```jsx
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

```jsx
Object.is({}, {}); // false

const a = {
  hello: 'hi',
};
const b = a;

Object.is(a, b); // true
a === b; // true
```

<aside>
👀 ***리액트에서 동등 비교는 `Object.is` 메서드를 활용하여 구현되어 있다.***

</aside>

### 리액트에서의 동등 비교

**알아야 할 것**

- JSX Props는 객체로 취급한다.
- `Object.is`는 참조가 다른 객체 간의 비교가 불가능하다.
- 리액트 팀은 `shallowEqual`이라는 메서드를 구현하여 1depth 까지 객체 간 비교가 가능하게 만들었다.

```tsx
type Props = {
  hello: string;
};

function HelloComponent(props: Props) {
  return <h1>{hello}</h1>;
}
//...

function App() {
  return <HelloComponent hello="hi!" />;
}
```

- 여기서 props는 객체다.
- 리액트는 props에서 꺼내온 값을 기준으로 렌더링한다.
- 일반적인 케이스에서 얕은 비교로 충분하다.
- 이러한 특성으로 props에 또 다른 객체를 넘겨주면 리액트 렌더링이 예상치 못하게 작동한다.
- 객체 안의 객체는 자바스크립트, 리액트에서 동등 비교가 어렵다는 것을 이해해야 한다.

<aside>
👀 ***리액트의 얕은 비교는 객체의 1 depth까지 비교할 수 있게 구현되어 있다는 점을 기억하자.
객체 안의 객체부터는 비교가 불가능하다.***

</aside>

<aside>
👀 ***자바스크립트 객체 비교의 불완전성은 다른 함수형 언어에서 볼 수 없는 자바스크립트만의 특징이다.
이러한 언어적 한계를 뛰어넘을 수 없으므로, 리액트는 얕은 비교만을 사용해 필요한 기능을 구현한다는 점을 꼭 숙지하자.***

</aside>

# 함수 (Function)

---

함수 파트에서는 기억해야 할 내용만 열거한다.

### 함수를 정의하는 4가지 방법

1. `함수 선언문` ― 사용됨
2. `함수 표현식` ― 사용됨
3. `Function 생성자` ― 거의 사용되지 않음
4. `화살표 함수` ― 각광받음

### 함수 선언문과 함수 표현식의 차이

```tsx
function add(a, b) {
  return a + b;
}
```

```tsx
const sum = function (a, b) {
  return a + b;
};
```

함수 선언문은 표현식이 아닌 일반 문(statement)로 분류되는데, 표현식이란 무언가 값을 산출하는 구문을 의미한다. 함수 선언으로는 어떠한 값도 표현되지 않았으므로 표현식이 아닌 문으로 분류한다.

두 정의법의 가장 큰 차이점은 **_호이스팅(hoisting)_** 여부다.

```tsx
hello(); // hello

function hello() {
  console.log('hello');
}

hello(); // hello
```

- 함수 선언문은 호이스팅된다.

```tsx
console.log(typeof hello === 'undefined'); // true
hello(); // Uncaught TypeError: hello is not a function

var hello = function () {
  console.log('hello');
};

hello();
```

- 함수 표현식에서 함수를 할당한 변수는 호이스팅된다.
- 하지만 호이스팅 되는 시점에서 `var`의 경우 `undefined`로 초기화한다.

### 화살표 함수 (Arrow Function)

ES6에서 추가된 함수 생성 방식으로 타이핑할 글자 수가 줄어들고, 앞의 함수 생성 방식과 몇 가지 큰 차이점이 존재한다. 바로 this 바인딩의 문제다.

**자바스크립트의 this 바인딩 요약**

---

자바스크립트의 this는 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다.

- 전역 스코프에서 사용되면 `this`는 전역 객체를 가리킨다.
  브라우저에서는 window 객체이고, 서버(노드)에서는 global 객체다.
- 함수에서 사용될 때에도 `this`는 전역 객체를 가리킨다.
- 객체에 속한 메서드에서 사용될 때 `this`는 메서드가 속한 객체를 가리킨다.
- 객체에 속한 메서드의 내부 함수에서 사용될 때 `this`는 전역 객체를 가리킨다.
- 생성자 함에서 사용될 때 `this`는 생성자로 인해 생성된 새로운 객체를 가리킨다.

---

<aside>
👀 ***내부 함수의 `this`가 지정되지 않고 전역 객체를 바인딩하는 문제는 자바스크립트 설계 상의 오류다. 원래 `this` 키워드는 다른 언어에서 ‘객체 자신에 대한 참조 값’을 의미한다. 따라서 자바스크립트에서는 내부 함수의 `this`가 전역 객체를 참조하는 것을 회피해야 한다.***

</aside>

[PoiemaWeb](https://poiemaweb.com/js-this)

자바스크립트의 this에 대한 내용

**화살표 함수와 다른 함수 정의법의 차이**

---

1. **생성자 함수로 화살표 함수를 사용하는 것은 불가능하다. ⇒ constructor 사용 불가**
2. **화살표 함수는 arguments를 가질 수 없다.**
3. **화살표 함수의 this는 함수 자체의 바인딩을 갖지 않는다. ⇒ this를 가지지 않는다!**
   화살표 함수를 선언하면 this에 바인딩할 객체가 일반 함수와는 달리 정적으로 결정된다. 내부에서 this를 참조하면 언제나 상위 스코프의 this를 따르게 된다. 이를 Lexical this라고 한다.

---

이 문제로 인해 화살표 함수를 메서드로 정의하거나, 프로토타입에 할당하거나, 생성자 함수로 사용하거나, addEventListener 함수의 콜백 함수로는 화살표 함수를 사용해서는 안된다.

<aside>
👀 ***화살표 함수는 별도의 작업을 추가로 하지 않고 `this`를 접근할 수 있다.***

</aside>

<aside>
👀 ***`this`를 사용할 수밖에 없는 클래스형 컴포넌트 내부에서 화살표 함수를 사용할 때는 각별한 주의가 필요하다.***

</aside>

### 리액트에서 자주 사용되는 함수의 형태

**즉시 실행 함수 (IIFE)**

- 한 번 선언하고 호출된 후 더 이상 재호출이 불가하므로, 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다는 장점이 있다.
- 함수가 어디서든 다시 호출되지 않는다는 점을 알 수 있어 리팩터링에 도움이 된다.
  ```tsx
  (function (a, b) {
  	return a + b
  })(10, 24); // 34

  ((a, b) => {
  	return a + b
  	},
  )(10, 24) // 34
  ```

**고차 함수 (Higher Order Function)**

- 자바스크립트의 함수가 일급 객체라는 특징을 활용하여 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다. 이 역할을 하는 함수가 고차 함수다.
  ```tsx
  // 함수를 매개변수로 받는 대표적인 고차 함수, Array.prototype.map
  const doubledArray = [1, 2, 3].map((item) =-> item * 2)

  doubledArray // [2,4,6]
  ```
  ```tsx
  // 함수를 반환하는 고차 함수의 예
  const add = function (a) {
    // a가 존재하는 클로저를 생성
    return function (b) {
      // b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
      return a + b;
    };
  };

  add(1)(3); // 4
  ```
- 이 특징으로 리액트에서 함수형 컴포넌트를 인수로 받아 새로운 함수형 컴포넌트를 반환하는 고차 함수를 만들 수 있다. 이를 고차 컴포넌트라고 부른다.
- 고차 함수형 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있기 때문에 효율적인 리팩터링이 가능하다.

### 함수를 만들 때 주의해야 할 사항

좋은 함수는 무엇이고 함수를 만들 때 무엇을 조심해야 하는가?

- **함수의 부수 효과(side-effect)를 최대한 억제하라**
  - 사이드 이펙트는 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다.
  - 부수 효과가 없는 함수를 순수 함수라고 한다. 이는 언제 실행되어도 항상 결과가 동일하다.
  - 웹 앱에서 부수 효과는 피할 수 없는 요소다.
    - 컴포넌트 내부에서 API를 호출한다면 외부 영향(HTTP request)을 끼쳤으므로 부수 효과다. console.log 또한 외부에 영향을 미친다. 하지만 최대한 억제할 수 있는 방향으로 함수를 설계해야 한다.
  - 리액트의 관점에서 useEffect의 작동을 최소화하는 것이 그 일환이다.
- **가능한 한 함수를 작게 만들어라**
  - 하나의 함수가 하는 일이 많아질 경우 문제를 일으킬 수 있는 여지가 커진다.
  - 하나의 함수는 하나의 일을 잘 하면 함수의 재사용성을 높일 수 있다.
- **누구나 이해할 수 있는 이름을 붙여라**
  - Terser를 사용하면 한글로 함수 네이밍이 가능하다. (개발 단의 코드 크기나 번들링 속도에서 부담이 될 가능성은 있다.)
  - 리액트의 useEffect, useCallback 등의 훅에 넘겨주는 콜백 함수에도 네이밍을 붙여주면 도움이 된다.

# 클래스 (Class)

---

### 왜 클래스를 알아야 되는가?

- 16.8 버전 이전의 리액트에서는 모든 컴포넌트가 클래스로 작성되어 있었다.
- 리액트가 함수형으로 패러다임을 바꾼 지 이해할 수 있다.
- 자바스크립트의 프로토타입 기반으로 작동하는 클래스를 이해하면 자연스럽게 프로토타입에 대해서도 이해할 수 있다.

### 클래스와 함수의 관계

- 자바스크립트 클래스는 프로토타입을 활용하여 구현됨
- 클래스는 객체지향 언어를 사용하던 개발자가 사용하기 편하도록 만들어주는 Syntactic Sugar

# 클로저 (Closure)

---

- 리액트 클래스형 컴포넌트의 이해 ← **_클래스, 프로토타입, this_**
- 리액트 함수형 컴포넌트의 이해 ← **_클로저_**

<aside>
👀 ***클로저의 정의 “함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합”***

</aside>

### 어휘적 환경

```jsx
function add() {
  const a = 10;
  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }
  innerAdd(); // 30
}

add();
```

- add 함수 내부에 innerAdd
  - innerAdd 함수는 내부에서 b 변수를 선언하고 외부 a와 더함
  - `a`의 유효범위는 `add`의 전체, `b`의 유효 범위는 `innerAdd`의 전체

선언된 어휘적 환경: 변수가 코드 내부에 어디서 선언되었는지 의미

<aside>
👀 ***자바스크립트는 함수 레벨 스코프를 따른다. `{}` 블록이 스코프 범위를 결정하지 않는다.***

</aside>

```jsx
function outerFunc() {
  var x = 'hello';
  function innerFunc() {
    console.log(x);
  }

  return innerFunc;
}

const innerFunc = outerFunc();
innerFunc(); // 'hello'
```

- 변수 `innerFunc`에는 함수 `innerFunc`가 반환되는데 `x` 변수의 값을 기억하고 있음
- 해당 함수가 선언된 어휘적 환경을 기억

### 클로저 활용

전역 스코프에 선언된 값은 누구든 접근할 수 있고 수정할 수 있다.

```jsx
var counter = 0;

function handleClick() {
  counter++;
}
```

**문제점**

- 전역에 `counter`가 선언되어 있어서 누구나 수정이 가능함

클로저를 활용한 코드로 수정해보자.

```jsx
function Counter() {
  var counter = 0;

  return {
    increase: function () {
      return ++counter;
    },
    decrease: function () {
      return --counter;
    },
    counter: function () {
      console.log('counter에 접근');
      return counter;
    },
  };
}

var c = Counter();

console.log(c.increase()); //1
console.log(c.increase()); //2
```

**장점**

- `counter` 변수에 접근할 수 없음
- `counter` 변수의 업데이트(수정)을 `increase`와 `decrease`로 제한함

### 리액트에서의 클로저

```jsx
function Component() {
  const [state, setState] = useState();

  function handleClick() {
    // useState 호출은 위에서 끝났지만,
    // setState는 계속 내부의 최신값(prev)을 알고 있다.
    // 이는 클로저를 활용했기 때문
    setState((prev) => prev + 1);
  }
  // ...
}
```

- `useState` 함수 호출은 Component 내부 첫 줄에서 종료되었는데, setState는 useState 내부의 최신 값을 계속 확인할 수 있다.
- 클로저가 useState 내부에서 활용되었기 때문
- 외부 함수 useState가 반환한 내부 함수 setState는 외부 함수의 호출이 끝났음에도 자신이 선언된 외부 함수가 선언된 환경 (state가 저장되어 있는 어딘가)을 기억하기 때문에 계속해서 state 값을 사용할 수 있다.

### 주의할 점

```jsx
for (var i = 0; i < 5; i+=) {
	setTimeout(function () {
		console.log(i)
	}, i * 1000)
}
```

- 0부터 시작해 1초 간격으로 그 다음 정수를 출력하는 것이 의도이다.
- 실제로 실행하면 0, 1, 2, 3, 4초 뒤에 5만 출력된다.
- setTimeout의 익명 함수가 클로저로 i를 잘 따라갈 것 같은데 모두 5가 되는 이유는?
  - `i`가 전역 변수로 동작하고 있기 때문이다.

1. 함수 레벨 스코프가 아닌 블록 레벨 스코프를 갖는 `let`으로 `i` 변수를 선언
2. 클로저를 제대로 활용하기

   ```jsx
   for (var i = 0; i < 5; i+=) {
   	setTimeout(
   		(function (sec) {
   			return function () {
   				console.log(sec)
   			}
   		})(i),
   		i * 1000,
   	)
   }
   ```

   - for문 내부에 즉시 실행 익명 함수를 선언
   - 즉시 실행 익명 함수는 for문마다 생성되고 실행되기를 반복
   - 각각의 함수는 고유의 스코프와 sec을 가지게 되므로 올바르게 동작

<aside>
👀 ***클로저를 사용하는 데는 비용이 발생한다. 성능에 영향을 미치는 작업이므로 꼭 필요한 곳에만 사용해야 하고 사용에 주의를 기울여야 한다.***

</aside>

# 이벤트 루프와 비동기 통신의 이해

---

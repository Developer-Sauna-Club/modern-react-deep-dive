- 자바스크립트의 동등 비교를 통해 리액트가 렌더링을 할지 결정한다

  - 자바스크립트의 데이터 타입
    - 원시타입 (7가지, 객체가 아닌 모든 타입)
      - 변경 불가능한 값을 저장
    - 객체타입 (객체)
      - 값의 주소를 저장 (=> 참조타입)
  - 값을 저장하는 방식의 차이
    - 원시타입
      - 불변 형태의 값으로 저장
      - 변수 할당 시 '값'이 메모리 영역을 차지
      - 복사 시 '값'을 전달
    - 객체타입
      - 변경 가능한 형태로 저장 (즉, 메모리 주소 변경 없이 프로퍼티 변경 가능)
      - 변수 할당 시 '주소(참조)'가 메모리 영역을 차지
      - 복사 시 '참조'를 전달
  - Object.is
    - 를 쓰더라도 객체의 동등비교에서는 ===와 차이가 없다.  
      즉 참조가 다른 객체는 다르다고 인식한다.
  - **리액트에서의 동등비교**
    - 먼저 `Object.is`를 통해 비교해서 걸러준다. (polyfill 사용)
      - 객체는 한 번 더 얕은비교
      - **얕은 비교까지만 하고 끝내는 이유?**
        - JSX props 객체의 props만 일차적으로 비교하면 되기 때문
        - 따라서 props가 중첩된 객체인 경우 비교가 제대로 작동하지 않는다. -> 변경된 값이 없고 + memo했음에도 리렌더링이 일어날 수 있다.
    - 비교해서 같으면 리렌더링 X, 다르면 리렌더링 O

- 함수
  - 함수를 정의하는 방법 4가지
    1. **함수 선언문**
       - 표현식이 _아닌_ 일반 문(statement)
         - 자바스크립트 엔진이 문맥에 따라 함수 선언문으로 해석하기도, 함수 리터럴 표현식으로 해석하기도 한다.
       - **함수 호이스팅 O**
         - 실행(런타임) 전에 메모리에 선언된 함수가 등록된다
    2. **함수 표현식**
       - 함수는 일급객체 (값의 성질을 갖는 객체)이므로 변수에 할당될 수 있다.
       - **함수 호이스팅 X**
         - 즉, 런타임에 함수 생성됨.
           물론 함수가 할당된 변수는 호이스팅되어 실행 전에 선언되지만, 할당은 실행하면서 되므로 실행 전까진 undefined 상태임
    3. Function 생성자 함수 (권장하지 않음)
    4. **화살표 함수** - _함수 표현식/선언문과의 차이_
       - constructor 사용 불가 -> 생성자 함수로서 호출할 수 없다.
       - arguments 없음
       - this 바인딩
         - 화살표함수는 함수 자체의 this 바인딩을 갖지 않는다
         - -> 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 참조한다
         - "콜백함수 내부의 this문제"를 해결한다.
           - this 바인딩은 함수가 어떻게 호출되었는지에 따라 결정된다
           - ex) 클래스의 메소드에서 콜백함수를 화살표함수로 작성하면 화살표함수로 호출되어 this는 상위 스코프인 인스턴스를 가리키게 된다 (lexical this) -> 개발자 의도대로 작동 가능!
             ```js
             class Prefixer {
               add(arr) {
                 return arr.map((item) => this.prefix + item);
               }
             }
             ```
  - 다양한 함수 살펴보기
    - 즉시 실행 함수
      - 정의와 동시에 실행
      - 단 한번만 호출, 선언과 동시에 실행이 거기서 끝남. 이름 X
      - -> 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프 운용 가능 (그 함수 내부에서만 접근할 수 있기 때문에)
    - 고차함수
      - 함수를 인수로 받거나 결과로 새로운 함수 반환 (함수는 일급객체)
      - 고차 함수 컴포넌트 (3.2절)
  - 함수를 만들 때 주의해야 할 사항
    - "함수의 부수효과를 최대한 억제하라"
      - 함수의 부수효과: 함수 외부에 영향을 끼치는 것
      - 부수효과가 많으면 개발자의 예측과 다른 결과를 일으켜 유지보수가 힘들어질 수 있다
      - useEffect의 작동을 최소화하는 것도 부수효과 줄이기 위함
    - "가능한 한 함수를 작게 만들어라"
      - 함수의 원래 목적은 재사용성을 높이는 것.
      - 함수는 하나의 일만 잘하면 그 목적을 달성하는 것이다.
    - "누구나 이해할 수 있는 이름을 붙여라"

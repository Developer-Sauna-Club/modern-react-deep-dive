- 자바스크립트의 동등 비교를 통해 리액트가 렌더링을 할지 결정한다

  - 자바스크립트의 데이터 타입
    - 원시타입 (7가지, 객체가 아닌 모든 타입)
      - 변경 불가능한 값을 저장
    - 객체타입 (객체)
      - 값의 주소를 저장 (=> 참조타입)
  - 값을 저장하는 방식의 차이
    - 원시타입
      - 불변 형태의 값으로 저장
      - 변수 할당 시 '값'이 메모리 영역을 차지
      - 복사 시 '값'을 전달
    - 객체타입
      - 변경 가능한 형태로 저장 (즉, 메모리 주소 변경 없이 프로퍼티 변경 가능)
      - 변수 할당 시 '주소(참조)'가 메모리 영역을 차지
      - 복사 시 '참조'를 전달
  - Object.is
    - 를 쓰더라도 객체의 동등비교에서는 ===와 차이가 없다.  
      즉 참조가 다른 객체는 다르다고 인식한다.
  - **리액트에서의 동등비교**
    - 먼저 `Object.is`를 통해 비교해서 걸러준다. (polyfill 사용)
      - 객체는 한 번 더 얕은비교
      - **얕은 비교까지만 하고 끝내는 이유?**
        - JSX props 객체의 props만 일차적으로 비교하면 되기 때문
        - 따라서 props가 중첩된 객체인 경우 비교가 제대로 작동하지 않는다. -> 변경된 값이 없고 + memo했음에도 리렌더링이 일어날 수 있다.
    - 비교해서 같으면 리렌더링 X, 다르면 리렌더링 O

- 함수
  - 함수를 정의하는 방법 4가지
    1. **함수 선언문**
       - 표현식이 _아닌_ 일반 문(statement)
         - 자바스크립트 엔진이 문맥에 따라 함수 선언문으로 해석하기도, 함수 리터럴 표현식으로 해석하기도 한다.
       - **함수 호이스팅 O**
         - 실행(런타임) 전에 메모리에 선언된 함수가 등록된다
    2. **함수 표현식**
       - 함수는 일급객체 (값의 성질을 갖는 객체)이므로 변수에 할당될 수 있다.
       - **함수 호이스팅 X**
         - 즉, 런타임에 함수 생성됨.
           물론 함수가 할당된 변수는 호이스팅되어 실행 전에 선언되지만, 할당은 실행하면서 되므로 실행 전까진 undefined 상태임
    3. Function 생성자 함수 (권장하지 않음)
    4. **화살표 함수** - _함수 표현식/선언문과의 차이_
       - constructor 사용 불가 -> 생성자 함수로서 호출할 수 없다.
       - arguments 없음
       - this 바인딩
         - 화살표함수는 함수 자체의 this 바인딩을 갖지 않는다
         - -> 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 참조한다
         - "콜백함수 내부의 this문제"를 해결한다.
           - this 바인딩은 함수가 어떻게 호출되었는지에 따라 결정된다
           - ex) 클래스의 메소드에서 콜백함수를 화살표함수로 작성하면 화살표함수로 호출되어 this는 상위 스코프인 인스턴스를 가리키게 된다 (lexical this) -> 개발자 의도대로 작동 가능!
             ```js
             class Prefixer {
               constructor(prefix) {
                 this.prefix = prefix;
               }
               add(arr) {
                 return arr.map((item) => this.prefix + item);
                 /* this가 인스턴스를 정상적으로 가리킨다 
                  (화살표함수 내의 this는 상위 스코프의 this를 참조하기 때문!) */
               }
             }
             ```
  - 다양한 함수 살펴보기
    - 즉시 실행 함수
      - 정의와 동시에 실행
      - 단 한번만 호출, 선언과 동시에 실행이 거기서 끝남. 이름 X
      - -> 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프 운용 가능 (그 함수 내부에서만 접근할 수 있기 때문에)
    - 고차함수
      - 함수를 인수로 받거나 결과로 새로운 함수 반환 (함수는 일급객체)
      - 고차 함수 컴포넌트 (3.2절)
  - 함수를 만들 때 주의해야 할 사항
    - "함수의 부수효과를 최대한 억제하라"
      - 함수의 부수효과: 함수 외부에 영향을 끼치는 것
      - 부수효과가 많으면 개발자의 예측과 다른 결과를 일으켜 유지보수가 힘들어질 수 있다
      - useEffect의 작동을 최소화하는 것도 부수효과 줄이기 위함
    - "가능한 한 함수를 작게 만들어라"
      - 함수의 원래 목적은 재사용성을 높이는 것.
      - 함수는 하나의 일만 잘하면 그 목적을 달성하는 것이다.
    - "누구나 이해할 수 있는 이름을 붙여라"
- 클래스  
  특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것 (템플릿)

  - 구성

    - constructor
    - getter, setter
    - 프로퍼티
    - 메서드

      - 인스턴스 메서드
        - 클래스 내부에서 선언한 메서드. 프로토타입 메서드.
        - 메서드는 메모리 절약을 위해 인스턴스의 부모인 **프로토타입에 선언**된다.
          따라서 인스턴스들은 프로토타입으로부터 메서드를 상속받아 사용한다. (프로토타입 체이닝)
      - 정적 메서드 (static)

        - 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드

          ```js
          class Car {
            static hello() {
              console.log("안녕");
            }
          }

          const myCar = new Car();
          myCar.hello(); // TypeError
          Car.hello(); // 안녕!
          ```

        - 정적메서드 내부의 this는 인스턴스가 아닌 클래스 자신을 가리킴 -> 일반적으로 사용하는 this로 사용할 수 없다

  - 상속
    - `~ extends React.Component`
    - `~ extends React.PureComponent`
  - 클래스와 함수의 관계
    - ES6때 생긴 개념
    - 이전에는 프로토타입을 활용해 클래스를 동일하게 구현
    - 프로토타입을 기반으로 작동
    - ES6미만 환경에서는 클래스를 구현하기 위해 헬퍼 함수를 만들어 동일하게 동작
    - 클래스 작동을 **'생성자 함수'로 유사하게 재현 가능**
    - 즉, 클래스는 **객체지향언어를 위한 문법적 설탕**.

- 클로저
  - "함수와 함수가 선언된 렉시컬(어휘적) 환경의 조합"
    - 선언된 렉시컬 환경: 변수/함수가 코드 내부에서 **어디서 선언됐는지**를 말함. 코드가 **작성된 순간에 '정적'으로 결정**된다.
    - 스코프
      - 자바스크립트는 기본적으로 함수 레벨 스코프
      - {} 블록이 아닌 함수 블록으로 스코프가 결정된다
      - cf) let, const는 블록 레벨 스코프
    - 함수는 자신이 존재하던 환경(= **선언된 렉시컬 환경** = **선언하며 정적으로 결정된 스코프**)을 기억한다.
      - 따라서 자기 자신(내부함수)이 선언된 렉시컬 환경(외부함수)이 종료됐음에도 그 환경을 기억해 같은 환경 안에 있던 변수를 참조할 수 있는 것임.
  - 클로저의 활용 방향
    - 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 개발자가 원하는 방향대로 조작하고 노출시킬 수 있다. (counter 클로저를 생각해보기!)
  - 리액트에서의 클로저
    - useState
      - useState함수 호출이 종료됐음에도 setState는 useState 내부의 최신 값을 계속 확인할 수 있음: 바로 클로저 때문! 즉, setState 자신이 선언된 렉시컬 환경을 기억하고, 그 렉시컬 환경 내에 있던 state를 계속해서 참조할 수 있는 것임.
  - 주의할 점
    - setTimeout의 예시
    - 클로저는 함수형 프로그래밍의 목적 (부수효과가 없고 순수해야 한다)을 달성하기 위해 적극적으로 사용된다.
    - 반면 클로저는 불필요하게 메모리를 잡아먹거나 적절한 스코프로 가둬두지 않으면 성능에 악영향을 미칠 수도 있다.
